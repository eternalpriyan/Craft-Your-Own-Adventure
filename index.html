<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Craft Your Own Adventure</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&family=IBM+Plex+Mono:wght@400;500;600&display=swap');
        
        :root {
            --bg-dark: #0a0a0f;
            --bg-panel: #12121a;
            --amber: #ffb000;
            --amber-dim: #cc8c00;
            --amber-glow: #ffb00033;
            --amber-bright: #ffc940;
            --text-dim: #665c40;
            --border: #2a2a35;
            --scanline: rgba(255, 176, 0, 0.03);
        }

        /* Light mode */
        body.light-mode {
            --bg-dark: #f5f0e6;
            --bg-panel: #ebe5d8;
            --amber: #8b6914;
            --amber-dim: #a07d1c;
            --amber-glow: #8b691433;
            --amber-bright: #6b4f0a;
            --text-dim: #998a6d;
            --border: #d4cbb8;
            --scanline: rgba(139, 105, 20, 0.02);
        }

        body.light-mode::before {
            opacity: 0.3;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'IBM Plex Mono', monospace;
            background: var(--bg-dark);
            color: var(--amber);
            min-height: 100vh;
            overflow: hidden;
        }
        
        /* CRT Scanline Effect */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                var(--scanline) 2px,
                var(--scanline) 4px
            );
            pointer-events: none;
            z-index: 9999;
        }
        
        
        /* ===== SPLASH SCREEN ===== */
        #splash {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: var(--bg-dark);
            z-index: 100;
            padding: 20px;
        }
        
        .ascii-art {
            font-family: 'VT323', monospace;
            font-size: 14px;
            line-height: 1.2;
            white-space: pre;
            color: var(--amber);
            text-shadow: 0 0 10px var(--amber-glow), 0 0 20px var(--amber-glow);
            margin-bottom: 40px;
        }
        
        @media (max-width: 700px) {
            .ascii-art {
                font-size: 10px;
            }
        }
        
        .splash-prompt {
            font-family: 'IBM Plex Mono', monospace;
            color: var(--amber-dim);
            font-size: 16px;
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        .splash-btn {
            margin-top: 30px;
            padding: 12px 40px;
            font-family: 'VT323', monospace;
            font-size: 24px;
            background: transparent;
            border: 2px solid var(--amber);
            color: var(--amber);
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .splash-btn:hover {
            background: var(--amber);
            color: var(--bg-dark);
            box-shadow: 0 0 20px var(--amber-glow), 0 0 40px var(--amber-glow);
        }
        
        /* ===== SETTINGS MODAL ===== */
        #settings-modal {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.9);
            z-index: 200;
        }
        
        #settings-modal.active {
            display: flex;
        }
        
        .modal-content {
            background: var(--bg-panel);
            border: 1px solid var(--amber-dim);
            padding: 40px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 0 40px var(--amber-glow);
        }
        
        .modal-content h2 {
            font-family: 'VT323', monospace;
            font-size: 28px;
            margin-bottom: 30px;
            text-transform: uppercase;
            letter-spacing: 3px;
        }
        
        .form-group {
            margin-bottom: 25px;
        }
        
        .form-group label {
            display: block;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--amber-dim);
            margin-bottom: 8px;
        }
        
        .form-group input {
            width: 100%;
            padding: 12px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 14px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            color: var(--amber);
            outline: none;
            transition: border-color 0.2s;
        }
        
        .form-group input:focus {
            border-color: var(--amber);
        }
        
        .form-group input::placeholder {
            color: var(--text-dim);
        }

        .form-group select {
            width: 100%;
            padding: 12px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 14px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            color: var(--amber);
            outline: none;
            cursor: pointer;
            transition: border-color 0.2s;
        }

        .form-group select:focus {
            border-color: var(--amber);
        }

        .form-group select option {
            background: var(--bg-dark);
            color: var(--amber);
        }

        .modal-buttons {
            display: flex;
            gap: 15px;
            margin-top: 30px;
        }

        /* Toggle switch */
        .toggle-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--border);
            border-radius: 13px;
            transition: 0.3s;
        }

        .toggle-slider::before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background: var(--amber-dim);
            border-radius: 50%;
            transition: 0.3s;
        }

        .toggle-switch input:checked + .toggle-slider {
            background: var(--amber);
        }

        .toggle-switch input:checked + .toggle-slider::before {
            transform: translateX(24px);
            background: var(--bg-dark);
        }

        .toggle-label {
            font-size: 14px;
            color: var(--amber);
        }

        /* Modal footer */
        .modal-footer {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid var(--border);
            text-align: center;
            font-size: 12px;
            color: var(--text-dim);
        }

        .modal-footer .authorship {
            margin-bottom: 12px;
        }

        .modal-footer .links {
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .modal-footer a {
            color: var(--amber-dim);
            text-decoration: none;
            transition: color 0.2s;
        }

        .modal-footer a:hover {
            color: var(--amber);
        }
        
        .btn {
            flex: 1;
            padding: 12px 20px;
            font-family: 'VT323', monospace;
            font-size: 18px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s;
        }
        
        .btn-primary {
            background: var(--amber);
            border: none;
            color: var(--bg-dark);
        }
        
        .btn-primary:hover {
            background: var(--amber-bright);
            box-shadow: 0 0 20px var(--amber-glow);
        }
        
        .btn-secondary {
            background: transparent;
            border: 1px solid var(--amber-dim);
            color: var(--amber-dim);
        }
        
        .btn-secondary:hover {
            border-color: var(--amber);
            color: var(--amber);
        }
        
        /* ===== MAIN APP ===== */
        #app {
            display: none;
            height: 100vh;
        }
        
        #app.active {
            display: flex;
        }
        
        /* Header */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 50px;
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 50;
        }
        
        .header-left {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .header-title {
            font-family: 'VT323', monospace;
            font-size: 20px;
            letter-spacing: 2px;
        }

        @media (max-width: 700px) {
            .header-title {
                display: none;
            }

            /* Compact model selector on mobile */
            .model-indicator {
                font-size: 10px;
                padding: 4px 8px;
                max-width: 90px;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }

            .model-dropdown {
                right: 0;
                left: auto;
            }

            /* Prevent iOS zoom on input focus (requires 16px min) */
            input, textarea, select {
                font-size: 16px !important;
            }

            /* Always show edit/delete icons on mobile */
            .suggestion-item .option-actions {
                opacity: 1 !important;
            }

            /* Smaller text on mobile */
            .story-content {
                font-size: 14px;
            }

            .story-segment.narration {
                line-height: 1.6;
            }

            .story-suggestions {
                font-size: 13px;
            }

            /* Compact settings modal on mobile */
            .modal-content {
                padding: 20px;
                max-height: 90vh;
                overflow-y: auto;
            }

            .modal-content h2 {
                font-size: 22px;
                margin-bottom: 20px;
            }

            .form-group {
                margin-bottom: 15px;
            }

            .form-group label {
                font-size: 11px;
                margin-bottom: 5px;
            }

            .form-group input,
            .form-group select {
                padding: 10px;
            }

            .modal-buttons {
                margin-top: 20px;
            }

            .modal-footer {
                margin-top: 20px;
                padding-top: 15px;
            }

            .btn {
                padding: 8px 16px;
                font-size: 16px;
            }
        }
        
        .header-right {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .model-selector {
            position: relative;
        }

        .model-indicator {
            font-size: 11px;
            color: var(--amber-dim);
            background: rgba(255, 176, 0, 0.1);
            padding: 4px 10px;
            border-radius: 3px;
            border: 1px solid var(--border);
            font-family: 'IBM Plex Mono', monospace;
            cursor: pointer;
            transition: all 0.2s;
        }

        .model-indicator:hover {
            color: var(--amber);
            border-color: var(--amber);
            background: rgba(255, 176, 0, 0.2);
        }

        .model-dropdown {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            margin-top: 5px;
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: 4px;
            min-width: 180px;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .model-dropdown.active {
            display: block;
        }

        .model-option {
            padding: 8px 12px;
            font-size: 12px;
            color: var(--amber-dim);
            cursor: pointer;
            font-family: 'IBM Plex Mono', monospace;
            border-bottom: 1px solid var(--border);
        }

        .model-option:last-child {
            border-bottom: none;
        }

        .model-option:hover {
            background: rgba(255, 176, 0, 0.1);
            color: var(--amber);
        }

        .model-option.selected {
            color: var(--amber);
            background: rgba(255, 176, 0, 0.15);
        }

        .model-option .model-tag {
            font-size: 9px;
            opacity: 0.6;
            margin-left: 6px;
        }

        .settings-btn {
            background: none;
            border: none;
            color: var(--amber-dim);
            font-size: 20px;
            cursor: pointer;
            padding: 5px;
            transition: color 0.2s;
        }
        
        .settings-btn:hover {
            color: var(--amber);
        }
        
        /* Header buttons */
        .header-btn {
            background: none;
            border: 1px solid var(--border);
            color: var(--amber-dim);
            padding: 4px 10px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .header-btn:hover:not(:disabled) {
            border-color: var(--amber);
            color: var(--amber);
        }

        .header-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        /* Main Content */
        .main-content {
            flex: 1;
            margin-top: 50px;
            display: flex;
            flex-direction: column;
            height: calc(100vh - 50px);
        }
        
        /* Story Display */
        .story-container {
            flex: 1;
            overflow-y: auto;
            padding: 30px;
            padding-bottom: 10px;
        }
        
        .story-content {
            max-width: 700px;
            margin: 0 auto;
            line-height: 1.8;
            font-size: 14px;
        }
        
        .story-segment {
            margin-bottom: 25px;
            padding-bottom: 25px;
            border-bottom: 1px solid var(--border);
        }
        
        .story-segment:last-child {
            border-bottom: none;
        }
        
        .story-segment.user-input {
            color: var(--amber-bright);
            font-style: italic;
        }
        
        .story-segment.user-input::before {
            content: '> ';
            color: var(--amber-dim);
        }
        
        .story-segment.narration {
            color: var(--amber);
        }

        .story-segment.narration p {
            margin: 0 0 1em 0;
        }

        .story-segment.narration p:last-child {
            margin-bottom: 0;
        }

        /* Markdown-style formatting */
        .story-segment.narration strong {
            color: var(--amber-bright);
            font-weight: 600;
        }

        .story-segment.narration em {
            font-style: italic;
            color: var(--amber);
        }

        /* Dialogue styling */
        .story-segment.narration .dialogue {
            color: var(--amber-bright);
            font-style: italic;
        }

        /* Blockquote for internal thoughts or emphasis */
        .story-segment.narration blockquote {
            border-left: 2px solid var(--amber-dim);
            padding-left: 1em;
            margin: 0.5em 0;
            color: var(--amber-dim);
            font-style: italic;
        }

        /* Narrative hover actions */
        .story-segment.narration {
            position: relative;
        }

        .narrative-actions {
            position: absolute;
            top: 0;
            right: 0;
            display: flex;
            gap: 8px;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .story-segment.narration:hover .narrative-actions {
            opacity: 1;
        }

        .narrative-btn {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            color: var(--text-dim);
            padding: 4px 10px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .narrative-btn:hover {
            border-color: var(--amber);
            color: var(--amber);
            background: rgba(255, 176, 0, 0.1);
        }

        /* Narrative edit mode */
        .story-segment.narration.editing {
            padding: 0;
        }

        .story-segment.narration.editing .narrative-actions {
            display: none;
        }

        .narrative-edit-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .narrative-edit-textarea {
            width: 100%;
            min-height: 200px;
            padding: 15px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 14px;
            line-height: 1.7;
            background: var(--bg-dark);
            border: 1px solid var(--amber-dim);
            color: var(--amber);
            resize: vertical;
            outline: none;
        }

        .narrative-edit-textarea:focus {
            border-color: var(--amber);
            box-shadow: 0 0 10px var(--amber-glow);
        }

        .narrative-edit-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .narrative-edit-btn {
            padding: 8px 20px;
            font-family: 'VT323', monospace;
            font-size: 16px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s;
        }

        .narrative-edit-btn.save {
            background: var(--amber);
            border: none;
            color: var(--bg-dark);
        }

        .narrative-edit-btn.save:hover {
            background: var(--amber-bright);
            box-shadow: 0 0 15px var(--amber-glow);
        }

        .narrative-edit-btn.cancel {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--amber-dim);
        }

        .narrative-edit-btn.cancel:hover {
            border-color: var(--amber);
            color: var(--amber);
        }

        /* Refresh Modal */
        #refresh-modal {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.85);
            z-index: 300;
        }

        #refresh-modal.active {
            display: flex;
        }

        .refresh-modal-content {
            background: var(--bg-panel);
            border: 1px solid var(--amber-dim);
            padding: 30px 40px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 0 40px var(--amber-glow);
        }

        .refresh-modal-content h3 {
            font-family: 'VT323', monospace;
            font-size: 24px;
            margin-bottom: 10px;
            color: var(--amber);
        }

        .refresh-modal-content p {
            color: var(--amber-dim);
            font-size: 13px;
            margin-bottom: 20px;
            line-height: 1.5;
        }

        .refresh-modal-textarea {
            width: 100%;
            min-height: 80px;
            padding: 12px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 14px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            color: var(--amber);
            resize: vertical;
            outline: none;
            margin-bottom: 20px;
        }

        .refresh-modal-textarea:focus {
            border-color: var(--amber);
        }

        .refresh-modal-textarea::placeholder {
            color: var(--text-dim);
        }

        .refresh-modal-buttons {
            display: flex;
            gap: 15px;
            justify-content: flex-end;
        }

        .story-suggestions {
            margin-top: 20px;
            padding: 15px;
            background: rgba(255, 176, 0, 0.05);
            border-left: 2px solid var(--amber-dim);
            position: relative;
        }

        .story-suggestions h4 {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--amber-dim);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .add-option-btn {
            background: none;
            border: 1px dashed var(--border);
            color: var(--text-dim);
            padding: 4px 10px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
        }

        /* Hide by default on desktop, show on hover */
        @media (hover: hover) {
            .add-option-btn {
                opacity: 0;
            }

            .story-suggestions:hover .add-option-btn {
                opacity: 1;
            }

            .story-suggestions.no-options .add-option-btn {
                opacity: 1;
            }
        }

        .add-option-btn:hover {
            border-color: var(--amber);
            color: var(--amber);
        }
        
        .suggestion-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 0;
            color: var(--amber-dim);
            cursor: pointer;
            transition: color 0.2s;
        }

        .suggestion-item .option-text {
            flex: 1;
        }

        .suggestion-item .option-actions {
            display: flex;
            gap: 8px;
            opacity: 0;
            transition: opacity 0.2s;
        }

        /* Only apply hover on devices that support it (not touch) */
        @media (hover: hover) {
            .suggestion-item:hover {
                color: var(--amber-bright);
            }

            .suggestion-item:hover .option-actions {
                opacity: 1;
            }
        }

        .option-btn {
            background: none;
            border: none;
            color: var(--text-dim);
            cursor: pointer;
            padding: 2px 6px;
            font-size: 12px;
            transition: color 0.2s;
        }

        .option-btn:hover {
            color: var(--amber-bright);
        }

        .option-btn.delete:hover {
            color: #ff5050;
        }

        /* Inline edit mode */
        .suggestion-item.editing {
            cursor: default;
        }

        .suggestion-item.editing .option-text {
            display: none;
        }

        .suggestion-item.editing .option-actions {
            display: none;
        }

        .option-edit-input {
            flex: 1;
            padding: 6px 10px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 14px;
            background: var(--bg-dark);
            border: 1px solid var(--amber-dim);
            color: var(--amber);
            outline: none;
        }

        .option-edit-input:focus {
            border-color: var(--amber);
        }
        
        .welcome-message {
            text-align: center;
            padding: 60px 20px;
            color: var(--amber-dim);
        }
        
        .welcome-message h2 {
            font-family: 'VT323', monospace;
            font-size: 28px;
            margin-bottom: 20px;
            color: var(--amber);
        }
        
        .welcome-message p {
            max-width: 500px;
            margin: 0 auto;
            line-height: 1.6;
        }
        
        /* Loading indicator */
        .loading {
            display: inline-block;
            color: var(--amber-dim);
        }
        
        .loading::after {
            content: '▋';
            animation: cursor-blink 0.8s infinite;
        }
        
        @keyframes cursor-blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        .streaming-cursor {
            animation: cursor-blink 0.8s infinite;
            color: var(--amber);
        }

        .sync-indicator {
            padding: 0.75rem 1rem;
            margin: 1rem 0;
            color: var(--amber-dim);
            font-style: italic;
            opacity: 0.8;
        }

        .sync-indicator::before {
            content: '';
            display: inline-block;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--bg-dark);
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--amber-dim);
        }
        
        /* Branch notification */
        .branch-notification {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--amber);
            color: var(--bg-dark);
            padding: 12px 25px;
            font-family: 'VT323', monospace;
            font-size: 16px;
            border-radius: 3px;
            box-shadow: 0 0 30px var(--amber-glow);
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 60;
        }
        
        .branch-notification.show {
            opacity: 1;
        }
        
        /* Error display */
        .error-message {
            background: rgba(255, 80, 80, 0.1);
            border: 1px solid #ff5050;
            color: #ff8080;
            padding: 15px;
            margin: 20px 0;
            font-size: 13px;
        }

        /* Delete Modal */
        #delete-modal {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.85);
            z-index: 300;
        }

        #delete-modal.active {
            display: flex;
        }

        .delete-modal-content {
            background: var(--bg-panel);
            border: 1px solid #ff5050;
            padding: 30px 40px;
            max-width: 400px;
            width: 90%;
            text-align: center;
            box-shadow: 0 0 40px rgba(255, 80, 80, 0.2);
        }

        .delete-modal-icon {
            font-size: 48px;
            margin-bottom: 15px;
            color: #ff5050;
        }

        .delete-modal-content h3 {
            font-family: 'VT323', monospace;
            font-size: 24px;
            margin-bottom: 10px;
            color: var(--amber);
        }

        .delete-modal-content p {
            color: var(--amber-dim);
            font-size: 14px;
            margin-bottom: 25px;
            line-height: 1.5;
        }

        .delete-modal-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .btn-danger {
            background: #ff5050;
            border: none;
            color: #fff;
        }

        .btn-danger:hover {
            background: #ff6b6b;
            box-shadow: 0 0 20px rgba(255, 80, 80, 0.3);
        }
    </style>
</head>
<body>
    <!-- Splash Screen -->
    <div id="splash">
        <pre class="ascii-art">
+------------------------------------------------+
|                                                |
|       CCCC RRRR   AA  FFFFF TTTTT              |
|      C     R   R A  A F       T                |
|      C     RRRR  AAAA FFF     T                |
|      C     R  R  A  A F       T                |
|       CCCC R   R A  A F       T                |
|                                                |
|          Y   Y  OOO  U   U RRRR                |
|           Y Y  O   O U   U R   R               |
|            Y   O   O U   U RRRR                |
|            Y   O   O U   U R  R                |
|            Y    OOO   UUU  R   R               |
|                                                |
|            OOO  W   W N   N                    |
|           O   O W   W NN  N                    |
|           O   O W W W N N N                    |
|           O   O WW WW N  NN                    |
|            OOO  W   W N   N                    |
|                                                |
|    AA  DDD  V   V EEEE N   N TTTTT U   U RRRR  |
|   A  A D  D V   V E    NN  N   T   U   U R   R |
|   AAAA D  D V   V EEE  N N N   T   U   U RRRR  |
|   A  A D  D  V V  E    N  NN   T   U   U R  R  |
|   A  A DDD    V   EEEE N   N   T    UUU  R   R |
|                                                |
|                 +----------+                   |
|          :::::::| ######## |:::::::            |
|          :::::::| #      # |:::::::            |
|          :::::::| #      # |:::::::            |
|                 +----++----+                   |
|                      ||                        |
|                WEST OF HOUSE                   |
|                                                |
|  You are standing in an open field west of    |
|  a white house, with a boarded front door.    |
|                                                |
|  >_                                            |
|                                                |
+------------------------------------------------+
        </pre>
        <div class="splash-prompt">Press any key or click to begin...</div>
        <button class="splash-btn" id="start-btn">Enter</button>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal">
        <div class="modal-content">
            <h2>⚙︎ Configuration</h2>
            <div class="form-group">
                <label>Gemini API Key <span style="font-weight: normal; color: var(--text-dim);">(leave blank for placeholder text)</span></label>
                <input type="password" id="gemini-key" placeholder="Enter your Gemini API key">
            </div>
            <div class="form-group">
                <label>Craft API URL</label>
                <input type="text" id="craft-token" placeholder="https://connect.craft.do/links/YOUR_LINK/api/v1">
            </div>
            <div class="form-group">
                <label>Document ID <span style="font-weight: normal; color: var(--text-dim);">(uses first doc if empty)</span></label>
                <input type="text" id="craft-doc-id" placeholder="Leave empty to auto-select">
            </div>
            <div class="form-group">
                <label>AI Model</label>
                <select id="ai-model">
                    <option value="">Placeholder (No API)</option>
                    <option value="gemini-2.5-flash">Gemini 2.5 Flash (Free)</option>
                    <option value="gemini-3-pro-preview">Gemini 3 Pro (Free)</option>
                </select>
            </div>
            <div class="form-group toggle-group">
                <span class="toggle-label">Dark</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="light-mode-toggle">
                    <span class="toggle-slider"></span>
                </label>
                <span class="toggle-label">Light</span>
            </div>
            <div class="modal-buttons">
                <button class="btn btn-secondary" id="cancel-settings">Cancel</button>
                <button class="btn btn-primary" id="save-settings">Save</button>
            </div>
            <div class="modal-footer">
                <div class="authorship">Made by Priyan Nithya & Claude Code</div>
                <div class="links">
                    <a href="https://github.com/eternalpriyan/Craft-Your-Own-Adventure" target="_blank">GitHub</a>
                    <a href="https://buymeacoffee.com/npsoy" target="_blank">Buy me a coffee</a>
                </div>
            </div>
        </div>
    </div>

    <!-- Main App -->
    <div id="app">
        <header class="header">
            <div class="header-left">
                <span class="header-title">CRAFT YOUR OWN ADVENTURE</span>
            </div>
            <div class="header-right">
                <div class="model-selector">
                    <span class="model-indicator" id="model-indicator" title="Click to change model">AI: DeepSeek</span>
                    <div class="model-dropdown" id="model-dropdown">
                        <div class="model-option" data-model="">Placeholder<span class="model-tag">offline</span></div>
                        <div class="model-option" data-model="gemini-2.5-flash">Gemini 2.5 Flash<span class="model-tag">free</span></div>
                        <div class="model-option" data-model="gemini-3-pro-preview">Gemini 3 Pro<span class="model-tag">free</span></div>
                    </div>
                </div>
                <button class="header-btn" id="back-btn" disabled title="Go back">← Back</button>
                <button class="header-btn" id="refresh-btn" title="Reload from Craft">↻ Refresh</button>
                <button class="settings-btn" id="open-settings" title="Settings">⚙︎</button>
            </div>
        </header>

        <main class="main-content">
            <div class="story-container" id="story-container">
                <div class="story-content" id="story-content"></div>
            </div>
        </main>
    </div>

    <!-- Branch Notification -->
    <div class="branch-notification" id="branch-notification">
        New branch created!
    </div>

    <!-- Delete Confirmation Modal -->
    <div id="delete-modal">
        <div class="delete-modal-content">
            <div class="delete-modal-icon">⚠</div>
            <h3>Delete Option?</h3>
            <p id="delete-modal-text">Are you sure you want to delete this option?</p>
            <div class="delete-modal-buttons">
                <button class="btn btn-secondary" id="delete-cancel">Cancel</button>
                <button class="btn btn-danger" id="delete-confirm">Delete</button>
            </div>
        </div>
    </div>

    <!-- Refresh/Regenerate Modal -->
    <div id="refresh-modal">
        <div class="refresh-modal-content">
            <h3>Regenerate Narrative</h3>
            <p>What would you like different? Leave blank to let the AI regenerate freely.</p>
            <textarea class="refresh-modal-textarea" id="refresh-prompt" placeholder="e.g., Make it more mysterious, add more dialogue, describe the setting in more detail..."></textarea>
            <div class="refresh-modal-buttons">
                <button class="btn btn-secondary" id="refresh-cancel">Cancel</button>
                <button class="btn btn-primary" id="refresh-confirm">Regenerate</button>
            </div>
        </div>
    </div>

    <script>
        // ===== STATE =====
        const state = {
            geminiKey: localStorage.getItem('cyoa_gemini_key') || '',
            craftToken: localStorage.getItem('cyoa_craft_token') || '',
            craftDocId: localStorage.getItem('cyoa_craft_doc_id') || '',
            aiModel: localStorage.getItem('cyoa_ai_model') || 'gemini-2.5-flash',
            lightMode: localStorage.getItem('cyoa_light_mode') === 'true',
            currentBranchId: null,
            adventureTree: null,
            conversationContext: [],
            isGenerating: false,
            isLoadingTree: false,
            appInitialized: false
        };

        // Apply theme on load
        function applyTheme() {
            if (state.lightMode) {
                document.body.classList.add('light-mode');
            } else {
                document.body.classList.remove('light-mode');
            }
        }
        applyTheme();

        // Model display names
        const modelNames = {
            '': 'Placeholder',
            'gemini-2.5-flash': 'Gemini 2.5 Flash',
            'gemini-3-pro-preview': 'Gemini 3 Pro'
        };

        // ===== AI PROMPTS (Single Source of Truth) =====
        const PROMPTS = {
            narrative: {
                system: `You are an interactive fiction narrator. Write punchy second-person narrative.

RULES:
- Write 1-2 paragraphs focused on ACTION - what happens, what changes
- Keep it moving - no lengthy descriptions, get to the point
- End on a moment of tension or discovery
- Do NOT include options/choices - just narrative
- Never break character`,
                withContext: (choice, context) => `STORY SO FAR:
${context}

---

The player now chose: "${choice}"

What happens next? 1-2 punchy paragraphs, focus on action.`,
                noContext: (choice) => `The player chose: "${choice}"

Begin this adventure with 1-2 punchy paragraphs. Focus on action.`,
                regenerate: (choice, guidance) => guidance
                    ? `The player chose: "${choice}"\n\nRewrite with this direction: "${guidance}"\n\n1-2 punchy paragraphs, focus on action.`
                    : `The player chose: "${choice}"\n\nFresh take - 1-2 punchy paragraphs, different direction, focus on action.`
            },
            options: {
                system: `You suggest possible actions for an interactive fiction game. Return ONLY a JSON array of exactly 2 short action phrases. No other text.

Example output:
["Search the room", "Open the door"]`,
                user: (narrative) => `Based on this story:
${narrative}

Suggest 2 possible actions the player could take next. Return ONLY a JSON array.`
            }
        };

        // ===== DOM ELEMENTS =====
        const $ = id => document.getElementById(id);
        const splash = $('splash');
        const settingsModal = $('settings-modal');
        const app = $('app');
        const storyContent = $('story-content');
        const storyContainer = $('story-container');
        const branchNotification = $('branch-notification');

        // ===== INITIALIZATION =====
        function init() {
            // Splash screen handlers
            $('start-btn').addEventListener('click', handleStart);
            document.addEventListener('keydown', handleStart, { once: true });
            splash.addEventListener('click', e => {
                if (e.target === splash) handleStart();
            });

            // Settings handlers
            $('save-settings').addEventListener('click', saveSettings);
            $('cancel-settings').addEventListener('click', () => {
                settingsModal.classList.remove('active');
                if (state.craftToken && state.craftDocId) {
                    showApp();
                }
            });
            $('open-settings').addEventListener('click', () => {
                populateSettingsForm();
                settingsModal.classList.add('active');
            });

            // Model dropdown
            setupModelDropdown();
            updateModelIndicator();

            // Back button
            $('back-btn').addEventListener('click', goBack);

            // Refresh button
            $('refresh-btn').addEventListener('click', refreshFromCraft);

            // Delete modal handlers
            $('delete-confirm').addEventListener('click', confirmDelete);
            $('delete-cancel').addEventListener('click', cancelDelete);

            // Refresh modal handlers
            $('refresh-confirm').addEventListener('click', confirmRefresh);
            $('refresh-cancel').addEventListener('click', cancelRefresh);
        }

        let startHandled = false;
        function handleStart() {
            if (startHandled) return;
            startHandled = true;

            splash.style.display = 'none';

            if (state.craftToken && state.craftDocId) {
                showApp();
            } else {
                populateSettingsForm();
                settingsModal.classList.add('active');
            }
        }

        function populateSettingsForm() {
            $('gemini-key').value = state.geminiKey;
            $('craft-token').value = state.craftToken;
            $('craft-doc-id').value = state.craftDocId;
            $('ai-model').value = state.aiModel;
            // Toggle: left = dark, right = light. Checked (right) = light mode
            $('light-mode-toggle').checked = state.lightMode;
        }

        function updateModelIndicator() {
            const indicator = $('model-indicator');
            const dropdown = $('model-dropdown');

            // Update indicator text
            if (state.geminiKey && state.aiModel) {
                const displayName = modelNames[state.aiModel] || 'Gemini';
                indicator.textContent = `AI: ${displayName}`;
            } else {
                indicator.textContent = 'AI: Placeholder';
            }

            // Update dropdown selection
            dropdown.querySelectorAll('.model-option').forEach(opt => {
                opt.classList.toggle('selected', opt.dataset.model === state.aiModel);
            });
        }

        // Model dropdown handlers
        function setupModelDropdown() {
            const indicator = $('model-indicator');
            const dropdown = $('model-dropdown');

            // Toggle dropdown on click
            indicator.addEventListener('click', (e) => {
                e.stopPropagation();
                dropdown.classList.toggle('active');
            });

            // Handle option selection
            dropdown.querySelectorAll('.model-option').forEach(opt => {
                opt.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const model = opt.dataset.model;

                    // Check if API key required
                    if (model && !state.geminiKey) {
                        alert('Please add your Gemini API key in Settings first.');
                        dropdown.classList.remove('active');
                        return;
                    }

                    // Update state and save
                    state.aiModel = model;
                    localStorage.setItem('cyoa_ai_model', model);

                    // Sync with settings dropdown
                    $('ai-model').value = model;

                    updateModelIndicator();
                    dropdown.classList.remove('active');
                });
            });

            // Close on click outside
            document.addEventListener('click', () => {
                dropdown.classList.remove('active');
            });
        }

        function saveSettings() {
            const geminiKey = $('gemini-key').value.trim();
            const craftToken = $('craft-token').value.trim();
            const craftDocId = $('craft-doc-id').value.trim();
            const aiModel = $('ai-model').value;
            // Toggle: left = dark, right = light. Checked (right) = light mode
            const lightMode = $('light-mode-toggle').checked;

            if (!craftToken) {
                alert('Please enter your Craft API URL');
                return;
            }

            // Ensure the Craft URL doesn't have trailing slash
            state.geminiKey = geminiKey; // Can be empty for placeholder mode
            state.craftToken = craftToken.replace(/\/$/, '');
            state.craftDocId = craftDocId; // Can be empty
            state.aiModel = aiModel;
            state.lightMode = lightMode;

            localStorage.setItem('cyoa_gemini_key', geminiKey);
            localStorage.setItem('cyoa_craft_token', state.craftToken);
            localStorage.setItem('cyoa_craft_doc_id', craftDocId);
            localStorage.setItem('cyoa_ai_model', aiModel);
            localStorage.setItem('cyoa_light_mode', lightMode);

            applyTheme();
            updateModelIndicator();
            settingsModal.classList.remove('active');
            showApp();
        }

        async function showApp() {
            // Prevent double initialization
            if (state.appInitialized) {
                console.log('App already initialized, skipping showApp()');
                return;
            }
            state.appInitialized = true;

            app.classList.add('active');
            updateModelIndicator();
            await loadAdventureTree();
        }

        // ===== CRAFT API =====
        // Base URL is the full connection URL provided by user (includes /api/v1)
        function getCraftBaseUrl() {
            return state.craftToken; // craftToken is actually the full API URL
        }

        async function craftRequest(endpoint, method = 'GET', body = null) {
            const headers = {
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            };

            const options = { method, headers };
            if (body) options.body = JSON.stringify(body);

            const baseUrl = getCraftBaseUrl();
            const url = `${baseUrl}/${endpoint}`;
            
            const response = await fetch(url, options);
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Craft API error ${response.status}: ${errorText}`);
            }
            return response.json();
        }

        async function loadAdventureTree() {
            // Prevent concurrent loads
            if (state.isLoadingTree) {
                console.log('Already loading tree, skipping...');
                return;
            }
            state.isLoadingTree = true;
            storyContent.innerHTML = '<div class="story-segment narration loading">Generating story...</div>';

            try {
                // First, list all documents to find ours or let user pick
                const docsResponse = await craftRequest('documents');
                const docs = docsResponse.items || [];
                
                if (docs.length === 0) {
                    showError('No documents found in this Craft connection.');
                    return;
                }

                // Find the specified doc or use first one
                let targetDoc = docs.find(d => d.id === state.craftDocId);
                if (!targetDoc) {
                    // If no specific doc ID, use the first non-deleted doc
                    targetDoc = docs.find(d => !d.isDeleted) || docs[0];
                    state.craftDocId = targetDoc.id;
                    localStorage.setItem('cyoa_craft_doc_id', targetDoc.id);
                }

                // Fetch the full document content with all nested blocks
                const docContent = await craftRequest(`blocks?id=${targetDoc.id}&maxDepth=-1`);

                // Debug: log raw API response
                console.log('Raw Craft response:', JSON.stringify(docContent, null, 2));

                // Build tree from blocks - page blocks become branches
                state.adventureTree = buildTreeFromBlocks(docContent, targetDoc.title);
                state.currentBranchId = targetDoc.id;

                // Debug: log tree structure
                console.log('Adventure tree:', JSON.stringify(state.adventureTree, null, 2));

                // Restore last viewed page, or default to root
                const savedPageId = localStorage.getItem('cyoa_current_page');
                const targetPageId = savedPageId && findNode(state.adventureTree, savedPageId)
                    ? savedPageId
                    : targetDoc.id;

                console.log('Navigating to:', targetPageId, savedPageId ? '(restored)' : '(root)');
                await loadPage(targetPageId);
            } catch (error) {
                console.error('Failed to load adventure tree:', error);
                showError(`Failed to load from Craft: ${error.message}`);
            } finally {
                state.isLoadingTree = false;
            }
        }

        function buildTreeFromBlocks(block, fallbackTitle = 'Adventure') {
            // Craft API: page blocks have type='page' and markdown IS the title
            // Text blocks have type='text' and markdown is the content
            const isPage = block.type === 'page';

            const node = {
                id: block.id,
                // For pages, markdown is the title
                title: isPage ? (block.markdown || fallbackTitle) : fallbackTitle,
                content: '', // Content from child text blocks
                children: []  // Child pages (options)
            };

            // Collect content from child TEXT blocks only
            let contentParts = [];

            if (block.content && Array.isArray(block.content)) {
                for (const child of block.content) {
                    if (child.type === 'page') {
                        // Child page (option)
                        const childNode = buildTreeFromBlocks(child, 'Option');
                        node.children.push(childNode);
                    } else if (child.type === 'text' && child.markdown && child.markdown.trim()) {
                        // Text block - add to content
                        contentParts.push(child.markdown.trim());
                    }
                }
            }

            node.content = contentParts.join('\n\n');
            return node;
        }

        // Find parent of a node
        function findParent(tree, targetId, parent = null) {
            if (!tree) return null;
            if (tree.id === targetId) return parent;
            for (const child of tree.children || []) {
                const found = findParent(child, targetId, tree);
                if (found) return found;
            }
            return null;
        }

        // Go back to parent page
        async function goBack() {
            if (state.isGenerating) return;
            const parent = findParent(state.adventureTree, state.currentBranchId);
            if (parent) {
                await loadPage(parent.id);
            }
        }

        // Refresh current page from Craft
        async function refreshFromCraft() {
            if (state.isGenerating || state.isLoadingTree) return;

            const refreshBtn = $('refresh-btn');
            refreshBtn.disabled = true;
            refreshBtn.textContent = '↻ Loading...';

            // Show loading in content area
            storyContent.innerHTML = '<div class="loading">Refreshing from Craft...</div>';

            // Reset initialization flags to allow reload
            state.appInitialized = false;
            state.isLoadingTree = false;

            await loadAdventureTree();

            refreshBtn.disabled = false;
            refreshBtn.textContent = '↻ Refresh';
        }

        // Update back button state
        function updateBackButton() {
            const backBtn = $('back-btn');
            const parent = findParent(state.adventureTree, state.currentBranchId);
            backBtn.disabled = !parent;
        }

        // ===== STEP 0: LOAD PAGE (Central function - everything funnels here) =====
        async function loadPage(pageId) {
            state.isGenerating = true;

            const node = findNode(state.adventureTree, pageId);

            if (!node) {
                console.error('Node not found:', pageId);
                state.isGenerating = false;
                return;
            }

            // Update current branch to actual node ID (might differ from original pageId)
            state.currentBranchId = node.id;
            localStorage.setItem('cyoa_current_page', node.id);

            // Check if page has content
            const hasContent = node.content && node.content.trim().length > 0;

            if (!hasContent) {
                // EMPTY PAGE: Generate content
                const isRoot = node.id === state.adventureTree?.id;
                console.log('Page empty, generating content for:', node.title, isRoot ? '(root)' : '');

                storyContent.innerHTML = '<div class="story-segment narration loading">Generating story...</div>';
                scrollToBottom();

                try {
                    let narrative, options;

                    if (isRoot) {
                        // EMPTY ROOT: Use predetermined welcome message and starter options
                        narrative = `Welcome, Adventurer. Your story awaits. Pick a path below to begin, or rewrite these options to craft something uniquely yours. Every choice branches into new possibilities, all preserved in your Craft document as a living record of your tale.`;
                        options = [
                            "Into the Dragon's Lair",
                            "The Lost Temple Adventure"
                        ];
                    } else {
                        // Normal empty page: generate via AI with story context
                        const path = getPathToNode(state.adventureTree, pageId);
                        const storyContext = buildStoryContext(path);

                        // Show title immediately, then stream narrative
                        storyContent.innerHTML = `
                            <div class="story-segment user-input">${escapeHtml(node.title)}</div>
                            <div class="story-segment narration streaming" data-page-id="${node.id}">
                                <div class="narrative-content"><span class="streaming-cursor">▌</span></div>
                            </div>`;
                        scrollToBottom();

                        // Stream narrative with live updates
                        const narrativeContent = storyContent.querySelector('.narrative-content');
                        narrative = await generateNarrative(node.title, storyContext, (partialText) => {
                            const paragraphs = partialText.split('\n\n').filter(p => p.trim());
                            const html = paragraphs.map(p => `<p>${parseMarkdown(p.trim())}</p>`).join('');
                            narrativeContent.innerHTML = html + '<span class="streaming-cursor">▌</span>';
                            scrollToBottom();
                        });

                        // Remove cursor after streaming complete
                        narrativeContent.innerHTML = narrativeContent.innerHTML.replace(/<span class="streaming-cursor">▌<\/span>/g, '');

                        options = await generateOptions(narrative);
                    }

                    // Update local tree
                    node.content = narrative;

                    // Show syncing indicator
                    const syncIndicator = document.createElement('div');
                    syncIndicator.className = 'sync-indicator';
                    syncIndicator.innerHTML = '⟳ Syncing with Craft...';
                    storyContent.appendChild(syncIndicator);
                    scrollToBottom();

                    // Sync to Craft FIRST (wait for real IDs before displaying)
                    try {
                        await syncPageToCraft(pageId, narrative, options);
                    } catch (err) {
                        console.error('Craft sync failed:', err);
                    }

                    // Remove sync indicator
                    syncIndicator.remove();

                    // Now display with real Craft IDs
                    displayPage(node);
                    updateBackButton();
                    state.isGenerating = false;
                    return;

                } catch (error) {
                    console.error('Generation error:', error);
                    storyContent.innerHTML = `<div class="error-message">Error: ${error.message}</div>`;
                    state.isGenerating = false;
                    return;
                }
            }

            // Display content and options
            displayPage(node);
            updateBackButton();

            state.isGenerating = false;
        }

        // Display page content and child pages as options
        function displayPage(node) {
            let html = '';

            // Show page title as header (skip for root document)
            const isRoot = node.id === state.adventureTree?.id;
            if (!isRoot) {
                html += `<div class="story-segment user-input">${escapeHtml(node.title)}</div>`;
            }

            // Show content (narrative) - convert line breaks to HTML and parse markdown
            if (node.content && node.content.trim()) {
                const paragraphs = node.content.split('\n\n').filter(p => p.trim());
                const contentHtml = paragraphs.map(p => `<p>${parseMarkdown(p.trim())}</p>`).join('');
                html += `
                    <div class="story-segment narration" data-page-id="${node.id}">
                        <div class="narrative-actions">
                            <button class="narrative-btn" onclick="editNarrative('${node.id}')" title="Edit">✎ Edit</button>
                            <button class="narrative-btn" onclick="refreshNarrative('${node.id}')" title="Regenerate">↻ Refresh</button>
                        </div>
                        <div class="narrative-content">${contentHtml}</div>
                    </div>`;
            }

            // Show child pages as options (always show container if page has content)
            if (node.content && node.content.trim()) {
                const optionsHtml = (node.children || []).map(child => {
                    const hasChildContent = child.content && child.content.trim().length > 0;
                    const statusClass = hasChildContent ? 'explored' : 'unexplored';
                    const statusIcon = hasChildContent ? '✓' : '→';
                    return `
                        <div class="suggestion-item ${statusClass}" data-page-id="${child.id}">
                            <span class="option-text" onclick="selectOption('${child.id}')">${statusIcon} ${escapeHtml(child.title)}</span>
                            <div class="option-actions">
                                <button class="option-btn edit" onclick="editOption(event, '${child.id}')" title="Edit">✎</button>
                                <button class="option-btn delete" onclick="deleteOption(event, '${child.id}')" title="Delete">✕</button>
                            </div>
                        </div>`;
                }).join('');

                const hasOptions = node.children && node.children.length > 0;
                html += `
                    <div class="story-suggestions ${hasOptions ? '' : 'no-options'}">
                        <h4>
                            <span>What will you do?</span>
                            <button class="add-option-btn" onclick="addNewOption()">+ New option</button>
                        </h4>
                        ${optionsHtml}
                    </div>
                `;
            }

            storyContent.innerHTML = html;
            scrollToBottom();
        }

        // Refresh a node's data from Craft
        async function refreshNode(pageId) {
            try {
                const response = await craftRequest(`blocks?id=${pageId}&maxDepth=1`);
                const node = findNode(state.adventureTree, pageId);
                if (node && response) {
                    // Update children from response
                    // For page blocks, markdown IS the title (not wrapped in <page> tags)
                    node.children = (response.content || [])
                        .filter(c => c.type === 'page')
                        .map(c => ({
                            id: c.id,
                            title: c.markdown || 'Option',
                            content: '',  // Content is in child text blocks, not fetched here
                            children: []
                        }));
                }
            } catch (error) {
                console.error('Failed to refresh node:', error);
            }
        }

        // Sync page to Craft - waits for completion before returning
        async function syncPageToCraft(pageId, narrative, options) {
            const node = findNode(state.adventureTree, pageId);
            if (!node) return;

            // 1. Write narrative to Craft
            await craftRequest('blocks', 'POST', {
                markdown: narrative,
                position: {
                    position: 'end',
                    pageId: pageId
                }
            });
            console.log('Wrote narrative to Craft page:', pageId);

            // 2. Create child pages in Craft and add to local tree with real IDs
            node.children = []; // Clear any existing children
            for (const optionTitle of options) {
                const response = await craftRequest('blocks', 'POST', {
                    markdown: `<page>${optionTitle}</page>`,
                    position: {
                        position: 'end',
                        pageId: pageId
                    }
                });

                const newPageId = response.items?.[0]?.id;
                if (newPageId) {
                    node.children.push({
                        id: newPageId,
                        title: optionTitle,
                        content: '',
                        children: []
                    });
                }
            }

            console.log('Craft sync complete for:', pageId);
        }

        // ===== GEMINI API =====
        function buildGeminiConfig() {
            const generationConfig = { temperature: 0.9, maxOutputTokens: 1024 };
            const model = state.aiModel || 'gemini-2.5-flash';

            // Disable/minimize thinking for speed
            if (model.startsWith('gemini-3')) {
                // Gemini 3 uses thinkingLevel
                generationConfig.thinkingConfig = { thinkingLevel: 'low' };
            } else if (model.startsWith('gemini-2.5')) {
                // Gemini 2.5 uses thinkingBudget - 0 disables thinking
                generationConfig.thinkingConfig = { thinkingBudget: 0 };
            }

            return generationConfig;
        }

        // Non-streaming call (for options JSON parsing)
        async function callGemini(systemPrompt, userPrompt) {
            const model = state.aiModel || 'gemini-2.5-flash';
            const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${state.geminiKey}`;

            const response = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    contents: [{ parts: [{ text: userPrompt }] }],
                    systemInstruction: { parts: [{ text: systemPrompt }] },
                    generationConfig: buildGeminiConfig()
                })
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Gemini API error ${response.status}: ${errorText}`);
            }

            const data = await response.json();
            return data.candidates[0].content.parts[0].text;
        }

        // Streaming call (for narrative - shows text as it arrives)
        async function callGeminiStream(systemPrompt, userPrompt, onChunk) {
            const model = state.aiModel || 'gemini-2.5-flash';
            const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:streamGenerateContent?alt=sse&key=${state.geminiKey}`;

            const response = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    contents: [{ parts: [{ text: userPrompt }] }],
                    systemInstruction: { parts: [{ text: systemPrompt }] },
                    generationConfig: buildGeminiConfig()
                })
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Gemini API error ${response.status}: ${errorText}`);
            }

            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let fullText = '';

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                const chunk = decoder.decode(value, { stream: true });
                const lines = chunk.split('\n');

                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        try {
                            const json = JSON.parse(line.slice(6));
                            const text = json.candidates?.[0]?.content?.parts?.[0]?.text || '';
                            if (text) {
                                fullText += text;
                                if (onChunk) onChunk(fullText);
                            }
                        } catch (e) {
                            // Skip malformed JSON chunks
                        }
                    }
                }
            }

            return fullText;
        }

        // ===== AI FUNCTIONS =====
        async function generateNarrative(choice, storyContext = null, onChunk = null) {
            // Placeholder mode - no API key or placeholder model selected
            if (!state.geminiKey || !state.aiModel) {
                const placeholder = `You chose: "${choice}"

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.

Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore.`;
                // Simulate streaming for placeholder
                if (onChunk) {
                    for (let i = 0; i < placeholder.length; i += 10) {
                        await new Promise(r => setTimeout(r, 20));
                        onChunk(placeholder.slice(0, i + 10));
                    }
                }
                return placeholder;
            }

            // Real AI generation using PROMPTS config
            const systemPrompt = PROMPTS.narrative.system;
            const userPrompt = storyContext
                ? PROMPTS.narrative.withContext(choice, storyContext)
                : PROMPTS.narrative.noContext(choice);

            // Use streaming if callback provided
            if (onChunk) {
                return await callGeminiStream(systemPrompt, userPrompt, onChunk);
            }
            return await callGemini(systemPrompt, userPrompt);
        }

        async function generateOptions(narrative) {
            // Placeholder mode - no API key or placeholder model selected
            if (!state.geminiKey || !state.aiModel) {
                await new Promise(r => setTimeout(r, 200));
                return [
                    "Option One",
                    "Option Two"
                ];
            }

            // Real AI generation using PROMPTS config
            const response = await callGemini(PROMPTS.options.system, PROMPTS.options.user(narrative));

            // Parse JSON from response (handle potential markdown code blocks)
            let jsonStr = response.trim();
            if (jsonStr.startsWith('```')) {
                jsonStr = jsonStr.replace(/```json?\n?/g, '').replace(/```/g, '').trim();
            }

            try {
                const options = JSON.parse(jsonStr);
                if (Array.isArray(options) && options.length >= 2) {
                    return options.slice(0, 2);
                }
            } catch (e) {
                console.error('Failed to parse options JSON:', e, jsonStr);
            }

            // Fallback if parsing fails
            return [
                "Option One",
                "Option Two"
            ];
        }

        function findNode(tree, id) {
            if (!tree) return null;
            if (tree.id === id) return tree;
            for (const child of tree.children || []) {
                const found = findNode(child, id);
                if (found) return found;
            }
            return null;
        }

        // Build path from root to target node (for story context)
        function getPathToNode(tree, targetId, path = []) {
            if (!tree) return null;

            const currentStep = { title: tree.title, content: tree.content };
            const newPath = [...path, currentStep];

            if (tree.id === targetId) return newPath;

            for (const child of tree.children || []) {
                const found = getPathToNode(child, targetId, newPath);
                if (found) return found;
            }
            return null;
        }

        // Format path as story context (full history - 1M token context allows it)
        function buildStoryContext(path) {
            if (!path || path.length <= 1) return null; // No context for root

            // Skip root, include full path
            const relevantPath = path.slice(1);

            return relevantPath
                .filter(step => step.content) // Only include explored pages
                .map((step, i) => `[Choice ${i + 1}: "${step.title}"]\n${step.content}`)
                .join('\n\n---\n\n');
        }

        // ===== GLOBAL FUNCTIONS =====
        // Global function for clicking an option (child page)
        window.selectOption = function(pageId) {
            if (state.isGenerating) return;
            loadPage(pageId);
        };

        // Edit an option inline
        window.editOption = function(event, pageId) {
            event.stopPropagation();
            if (state.isGenerating) return;

            // Capture parent ID at edit start
            const parentId = state.currentBranchId;
            const node = findNode(state.adventureTree, pageId);
            if (!node) return;

            const itemEl = event.target.closest('.suggestion-item');
            if (!itemEl) return;

            // Enter edit mode
            itemEl.classList.add('editing');

            // Create input field
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'option-edit-input';
            input.value = node.title;
            input.dataset.pageId = pageId;
            input.dataset.originalTitle = node.title;

            const refreshDisplay = () => {
                const parentNode = findNode(state.adventureTree, parentId);
                if (parentNode) {
                    displayPage(parentNode);
                }
            };

            // Handle Enter to save, Escape to cancel
            input.addEventListener('keydown', async (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const newTitle = input.value.trim();
                    if (newTitle && newTitle !== node.title) {
                        await updateOptionTitle(pageId, newTitle, parentId);
                    } else {
                        refreshDisplay();
                    }
                } else if (e.key === 'Escape') {
                    refreshDisplay();
                }
            });

            // Also cancel on blur
            input.addEventListener('blur', () => {
                setTimeout(() => {
                    if (!document.contains(input)) return;
                    refreshDisplay();
                }, 100);
            });

            itemEl.appendChild(input);
            input.focus();
            input.select();
        };

        // Delete an option - show custom modal
        window.deleteOption = function(event, pageId) {
            event.stopPropagation();
            if (state.isGenerating) return;

            const node = findNode(state.adventureTree, pageId);
            if (!node) return;

            // Show custom delete modal
            const modal = $('delete-modal');
            const modalText = $('delete-modal-text');
            modalText.textContent = `"${truncate(node.title, 40)}"`;
            modal.classList.add('active');

            // Store pageId and parentId for confirm handler
            modal.dataset.pageId = pageId;
            modal.dataset.parentId = state.currentBranchId;
        };

        // Confirm delete from modal
        async function confirmDelete() {
            const modal = $('delete-modal');
            const pageId = modal.dataset.pageId;
            const parentId = modal.dataset.parentId;
            modal.classList.remove('active');

            if (!pageId || !parentId) return;

            // Optimistic UI - remove immediately
            const parentNode = findNode(state.adventureTree, parentId);
            if (parentNode) {
                parentNode.children = parentNode.children.filter(c => c.id !== pageId);
                displayPage(parentNode);
            }

            // Sync with Craft in background
            deleteBlock(pageId).catch(error => {
                console.error('Failed to sync delete with Craft:', error);
            });
        }

        function cancelDelete() {
            $('delete-modal').classList.remove('active');
        }

        // ===== NARRATIVE EDIT/REFRESH =====
        // Edit narrative inline
        window.editNarrative = function(pageId) {
            if (state.isGenerating) return;

            const node = findNode(state.adventureTree, pageId);
            if (!node) return;

            const narrativeEl = document.querySelector(`.story-segment.narration[data-page-id="${pageId}"]`);
            if (!narrativeEl) return;

            // Enter edit mode
            narrativeEl.classList.add('editing');

            // Replace content with textarea
            narrativeEl.innerHTML = `
                <div class="narrative-edit-container">
                    <textarea class="narrative-edit-textarea" id="narrative-edit-textarea">${escapeHtml(node.content)}</textarea>
                    <div class="narrative-edit-buttons">
                        <button class="narrative-edit-btn cancel" onclick="cancelEditNarrative('${pageId}')">Cancel</button>
                        <button class="narrative-edit-btn save" onclick="saveNarrative('${pageId}')">Save</button>
                    </div>
                </div>
            `;

            // Focus the textarea
            const textarea = document.getElementById('narrative-edit-textarea');
            textarea.focus();
            textarea.setSelectionRange(textarea.value.length, textarea.value.length);

            // Handle Escape to cancel
            textarea.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    cancelEditNarrative(pageId);
                } else if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
                    e.preventDefault();
                    saveNarrative(pageId);
                }
            });
        };

        // Save edited narrative
        window.saveNarrative = async function(pageId) {
            const textarea = document.getElementById('narrative-edit-textarea');
            if (!textarea) return;

            const newContent = textarea.value.trim();
            if (!newContent) {
                cancelEditNarrative(pageId);
                return;
            }

            const node = findNode(state.adventureTree, pageId);
            if (!node) return;

            // Update local tree immediately
            node.content = newContent;

            // Re-render the CURRENT page (not necessarily the edited node)
            const currentNode = findNode(state.adventureTree, state.currentBranchId);
            if (currentNode) {
                displayPage(currentNode);
            }

            // Update Craft in background
            console.log('Saving narrative to Craft for page:', pageId);
            updateNarrativeInCraft(pageId, newContent).then(() => {
                console.log('Successfully synced narrative to Craft');
            }).catch(error => {
                console.error('Failed to sync narrative with Craft:', error);
            });
        };

        // Cancel narrative edit
        window.cancelEditNarrative = function(pageId) {
            // Re-render the CURRENT page
            const currentNode = findNode(state.adventureTree, state.currentBranchId);
            if (currentNode) {
                displayPage(currentNode);
            }
        };

        // Open refresh modal
        window.refreshNarrative = function(pageId) {
            if (state.isGenerating) return;

            const modal = $('refresh-modal');
            const promptInput = $('refresh-prompt');

            // Clear previous prompt
            promptInput.value = '';

            // Store pageId for confirm handler
            modal.dataset.pageId = pageId;
            modal.classList.add('active');

            // Focus the input
            promptInput.focus();

            // Handle Enter to confirm
            promptInput.addEventListener('keydown', function handler(e) {
                if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
                    e.preventDefault();
                    confirmRefresh();
                    promptInput.removeEventListener('keydown', handler);
                } else if (e.key === 'Escape') {
                    cancelRefresh();
                    promptInput.removeEventListener('keydown', handler);
                }
            });
        };

        // Confirm refresh from modal
        async function confirmRefresh() {
            const modal = $('refresh-modal');
            const pageId = modal.dataset.pageId;
            const prompt = $('refresh-prompt').value.trim();
            modal.classList.remove('active');

            if (!pageId) return;

            const node = findNode(state.adventureTree, pageId);
            if (!node) return;

            state.isGenerating = true;

            // Show loading state
            const narrativeEl = document.querySelector(`.story-segment.narration[data-page-id="${pageId}"]`);
            if (narrativeEl) {
                narrativeEl.innerHTML = '<div class="loading">Regenerating...</div>';
            }

            try {
                // Generate new narrative with optional prompt and story context
                const path = getPathToNode(state.adventureTree, pageId);
                const storyContext = buildStoryContext(path);
                const newContent = await regenerateNarrative(node.title, node.content, prompt, storyContext);

                // Update local tree
                node.content = newContent;

                // Regenerate empty options only (keep explored ones)
                const children = node.children || [];
                const emptyChildren = children.filter(c => !c.content || !c.content.trim());
                const exploredChildren = children.filter(c => c.content && c.content.trim());

                let newOptions = [];
                if (emptyChildren.length > 0 || children.length === 0) {
                    newOptions = await generateOptions(newContent);
                }

                // Show syncing indicator
                const syncIndicator = document.createElement('div');
                syncIndicator.className = 'sync-indicator';
                syncIndicator.innerHTML = '⟳ Syncing with Craft...';
                storyContent.appendChild(syncIndicator);

                // Sync to Craft - await completion
                try {
                    // Update narrative
                    await updateNarrativeInCraft(pageId, newContent);

                    // Handle options if we need to regenerate them
                    if (newOptions.length > 0) {
                        // Delete empty children from Craft
                        for (const child of emptyChildren) {
                            await deletePageFromCraft(child.id);
                        }

                        // Create new options and get real IDs
                        node.children = [...exploredChildren];
                        for (const optionTitle of newOptions) {
                            const newPageId = await createOptionInCraft(pageId, optionTitle);
                            if (newPageId) {
                                node.children.push({
                                    id: newPageId,
                                    title: optionTitle,
                                    content: '',
                                    children: []
                                });
                            }
                        }
                    }
                } catch (err) {
                    console.error('Craft sync failed:', err);
                }

                syncIndicator.remove();

                // Re-render with real IDs
                displayPage(node);

            } catch (error) {
                console.error('Regeneration error:', error);
                // Re-render current state on error
                displayPage(node);
            }

            state.isGenerating = false;
        }

        function cancelRefresh() {
            $('refresh-modal').classList.remove('active');
        }

        // Regenerate narrative with optional guidance
        async function regenerateNarrative(choice, currentContent, guidance, storyContext = null) {
            // Placeholder mode - no API key or placeholder model selected
            if (!state.geminiKey || !state.aiModel) {
                await new Promise(r => setTimeout(r, 800));
                if (guidance) {
                    return `[Regenerated with guidance: "${guidance}"]\n\nYou chose: "${choice}"\n\nThe story continues with your requested changes. Lorem ipsum dolor sit amet.`;
                } else {
                    return `[Regenerated freely]\n\nYou chose: "${choice}"\n\nA fresh take unfolds. Sed ut perspiciatis unde omnis iste natus error sit.`;
                }
            }

            // Real AI regeneration using PROMPTS config
            let userPrompt = storyContext
                ? `STORY SO FAR:\n${storyContext}\n\n---\n\n` + PROMPTS.narrative.regenerate(choice, guidance)
                : PROMPTS.narrative.regenerate(choice, guidance);

            return await callGemini(PROMPTS.narrative.system, userPrompt);
        }

        // Update narrative content in Craft
        // Craft stores each paragraph as a separate text block, so we need to handle that
        // NOTE: We only touch TEXT blocks, never page blocks (they have nested content!)
        async function updateNarrativeInCraft(pageId, newContent) {
            console.log('updateNarrativeInCraft called with pageId:', pageId);

            // Fetch current page structure
            const response = await craftRequest(`blocks?id=${pageId}&maxDepth=1`);

            // Only touch text blocks - NEVER delete page blocks (they have nested content!)
            const textBlocks = (response.content || []).filter(c => c.type === 'text');

            // Split new content into paragraphs (Craft stores each as separate block)
            const paragraphs = newContent.split('\n\n').filter(p => p.trim());

            // Step 1: Delete existing text blocks only
            if (textBlocks.length > 0) {
                const blockIds = textBlocks.map(b => b.id);
                await craftRequest('blocks', 'DELETE', { blockIds });
            }

            // Step 2: Create new text blocks at START of page (before options)
            for (let i = paragraphs.length - 1; i >= 0; i--) {
                const paragraph = paragraphs[i].trim();
                if (!paragraph) continue;
                await craftRequest('blocks', 'POST', {
                    markdown: paragraph,
                    position: { position: 'start', pageId: pageId }
                });
            }

            console.log('Successfully updated narrative in Craft');
        }

        // Add a new option
        window.addNewOption = async function() {
            if (state.isGenerating) return;

            const parentId = state.currentBranchId;
            const parentNode = findNode(state.adventureTree, parentId);
            if (!parentNode) return;

            // Create temporary placeholder in local tree (temp ID for editing UI only)
            const tempId = 'temp-' + Date.now();
            const newNode = {
                id: tempId,
                title: '',
                content: '',
                children: []
            };
            parentNode.children.push(newNode);

            // Re-render to show the new option
            displayPage(parentNode);

            // Find the new item and trigger edit mode
            const newItem = document.querySelector(`[data-page-id="${tempId}"]`);
            if (newItem) {
                newItem.classList.add('editing');

                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'option-edit-input';
                input.placeholder = 'Enter option text...';
                input.dataset.pageId = tempId;
                input.dataset.isNew = 'true';

                const cancelNewOption = () => {
                    const currentParent = findNode(state.adventureTree, parentId);
                    if (currentParent) {
                        currentParent.children = currentParent.children.filter(c => c.id !== tempId);
                        displayPage(currentParent);
                    }
                };

                input.addEventListener('keydown', async (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        const title = input.value.trim();
                        if (title) {
                            await saveNewOption(tempId, title, parentId);
                        } else {
                            cancelNewOption();
                        }
                    } else if (e.key === 'Escape') {
                        cancelNewOption();
                    }
                });

                input.addEventListener('blur', () => {
                    setTimeout(() => {
                        // Check if input still exists (wasn't already handled by Enter/Escape)
                        if (!document.contains(input)) return;
                        const title = input.value.trim();
                        if (title) {
                            saveNewOption(tempId, title, parentId);
                        } else {
                            cancelNewOption();
                        }
                    }, 100);
                });

                newItem.appendChild(input);
                input.focus();
            }
        };

        // Save a new option to Craft
        async function saveNewOption(tempId, title, parentId) {
            const parentNode = findNode(state.adventureTree, parentId);
            if (!parentNode) return;

            // Update temp node with title
            const tempNode = parentNode.children.find(c => c.id === tempId);
            if (tempNode) {
                tempNode.title = title;
            }

            // Show sync indicator
            const syncIndicator = document.createElement('div');
            syncIndicator.className = 'sync-indicator';
            syncIndicator.innerHTML = '⟳ Syncing with Craft...';
            storyContent.appendChild(syncIndicator);

            // Create in Craft (await completion)
            try {
                const newPageId = await createOptionInCraft(parentId, title);
                if (newPageId && tempNode) {
                    tempNode.id = newPageId;
                }
            } catch (error) {
                console.error('Failed to create option in Craft:', error);
            }

            syncIndicator.remove();
            displayPage(parentNode);
        }

        async function writeToCraft(content) {
            try {
                console.log('Writing content to Craft page:', state.currentBranchId);

                // Insert content using markdown format
                const response = await craftRequest('blocks', 'POST', {
                    markdown: content,
                    position: {
                        position: 'end',
                        pageId: state.currentBranchId
                    }
                });

                console.log('Write to Craft response:', response);

                // Update local tree - use content property now
                const node = findNode(state.adventureTree, state.currentBranchId);
                if (node) {
                    node.content = content;
                }
            } catch (error) {
                console.error('Failed to write to Craft:', error);
                throw error;
            }
        }

        // Update option title in Craft (optimistic UI)
        async function updateOptionTitle(pageId, newTitle, parentId) {
            // Update local tree immediately
            const node = findNode(state.adventureTree, pageId);
            if (node) {
                node.title = newTitle;
            }

            // Refresh display instantly using captured parentId
            const parentNode = findNode(state.adventureTree, parentId);
            if (parentNode) {
                displayPage(parentNode);
            }

            // Sync with Craft in background
            craftRequest('blocks', 'PUT', {
                blocks: [{
                    id: pageId,
                    markdown: newTitle
                }]
            }).catch(error => {
                console.error('Failed to sync with Craft:', error);
            });
        }

        // Delete a block from Craft
        async function deleteBlock(blockId) {
            // Craft API uses DELETE /blocks with JSON body containing blockIds array
            const response = await craftRequest('blocks', 'DELETE', {
                blockIds: [blockId]
            });
            return response;
        }

        // Delete a page from Craft
        async function deletePageFromCraft(pageId) {
            return deleteBlock(pageId);
        }

        // Create a new option (child page) in Craft
        async function createOptionInCraft(parentId, title) {
            const response = await craftRequest('blocks', 'POST', {
                markdown: `<page>${title}</page>`,
                position: {
                    position: 'end',
                    pageId: parentId
                }
            });

            return response.items?.[0]?.id;
        }

        function showBranchNotification(title) {
            branchNotification.textContent = `New branch: ${title}`;
            branchNotification.classList.add('show');
            setTimeout(() => {
                branchNotification.classList.remove('show');
            }, 3000);
        }

        // ===== UTILITIES =====
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Simple markdown parser for narrative text
        function parseMarkdown(text) {
            let html = escapeHtml(text);

            // Bold: **text** or __text__
            html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
            html = html.replace(/__(.+?)__/g, '<strong>$1</strong>');

            // Italic: *text* or _text_
            html = html.replace(/\*([^*]+?)\*/g, '<em>$1</em>');
            html = html.replace(/_([^_]+?)_/g, '<em>$1</em>');

            // Dialogue: "text" - wrap in span with dialogue class
            html = html.replace(/"([^"]+)"/g, '<span class="dialogue">"$1"</span>');

            // Blockquote lines starting with >
            html = html.replace(/^&gt;\s*(.+)$/gm, '<blockquote>$1</blockquote>');

            return html;
        }

        function truncate(str, len) {
            return str.length > len ? str.substring(0, len) + '...' : str;
        }

        function scrollToBottom() {
            storyContainer.scrollTop = storyContainer.scrollHeight;
        }

        function showError(message) {
            storyContent.innerHTML = `<div class="error-message">${escapeHtml(message)}</div>`;
        }

        // Initialize on load
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
