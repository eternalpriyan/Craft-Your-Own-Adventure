<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Craft Your Own Adventure</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&family=IBM+Plex+Mono:wght@400;500;600&display=swap');
        
        :root {
            --bg-dark: #0a0a0f;
            --bg-panel: #12121a;
            --amber: #ffb000;
            --amber-dim: #cc8c00;
            --amber-glow: #ffb00033;
            --amber-bright: #ffc940;
            --text-dim: #665c40;
            --border: #2a2a35;
            --scanline: rgba(255, 176, 0, 0.03);
        }

        /* Light mode */
        body.light-mode {
            --bg-dark: #f5f0e6;
            --bg-panel: #ebe5d8;
            --amber: #8b6914;
            --amber-dim: #a07d1c;
            --amber-glow: #8b691433;
            --amber-bright: #6b4f0a;
            --text-dim: #998a6d;
            --border: #d4cbb8;
            --scanline: rgba(139, 105, 20, 0.02);
        }

        body.light-mode::before {
            opacity: 0.3;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'IBM Plex Mono', monospace;
            background: var(--bg-dark);
            color: var(--amber);
            min-height: 100vh;
            overflow: hidden;
        }
        
        /* CRT Scanline Effect */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                var(--scanline) 2px,
                var(--scanline) 4px
            );
            pointer-events: none;
            z-index: 9999;
        }
        
        
        /* ===== SPLASH SCREEN ===== */
        #splash {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: var(--bg-dark);
            z-index: 100;
            padding: 20px;
        }
        
        .ascii-art {
            font-family: 'VT323', monospace;
            font-size: 14px;
            line-height: 1.2;
            white-space: pre;
            color: var(--amber);
            text-shadow: 0 0 10px var(--amber-glow), 0 0 20px var(--amber-glow);
            margin-bottom: 40px;
        }
        
        @media (max-width: 700px) {
            .ascii-art {
                font-size: 8px;
            }
        }
        
        .splash-prompt {
            font-family: 'IBM Plex Mono', monospace;
            color: var(--amber-dim);
            font-size: 16px;
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        .splash-btn {
            margin-top: 30px;
            padding: 12px 40px;
            font-family: 'VT323', monospace;
            font-size: 24px;
            background: transparent;
            border: 2px solid var(--amber);
            color: var(--amber);
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .splash-btn:hover {
            background: var(--amber);
            color: var(--bg-dark);
            box-shadow: 0 0 20px var(--amber-glow), 0 0 40px var(--amber-glow);
        }
        
        /* ===== SETTINGS MODAL ===== */
        #settings-modal {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.9);
            z-index: 200;
        }
        
        #settings-modal.active {
            display: flex;
        }
        
        .modal-content {
            background: var(--bg-panel);
            border: 1px solid var(--amber-dim);
            padding: 40px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 0 40px var(--amber-glow);
        }
        
        .modal-content h2 {
            font-family: 'VT323', monospace;
            font-size: 28px;
            margin-bottom: 30px;
            text-transform: uppercase;
            letter-spacing: 3px;
        }
        
        .form-group {
            margin-bottom: 25px;
        }
        
        .form-group label {
            display: block;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--amber-dim);
            margin-bottom: 8px;
        }
        
        .form-group input {
            width: 100%;
            padding: 12px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 14px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            color: var(--amber);
            outline: none;
            transition: border-color 0.2s;
        }
        
        .form-group input:focus {
            border-color: var(--amber);
        }
        
        .form-group input::placeholder {
            color: var(--text-dim);
        }

        .form-group select {
            width: 100%;
            padding: 12px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 14px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            color: var(--amber);
            outline: none;
            cursor: pointer;
            transition: border-color 0.2s;
        }

        .form-group select:focus {
            border-color: var(--amber);
        }

        .form-group select option {
            background: var(--bg-dark);
            color: var(--amber);
        }

        .modal-buttons {
            display: flex;
            gap: 15px;
            margin-top: 30px;
        }

        /* Toggle switch */
        .toggle-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--border);
            border-radius: 13px;
            transition: 0.3s;
        }

        .toggle-slider::before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background: var(--amber-dim);
            border-radius: 50%;
            transition: 0.3s;
        }

        .toggle-switch input:checked + .toggle-slider {
            background: var(--amber);
        }

        .toggle-switch input:checked + .toggle-slider::before {
            transform: translateX(24px);
            background: var(--bg-dark);
        }

        .toggle-label {
            font-size: 14px;
            color: var(--amber);
        }

        /* Modal footer */
        .modal-footer {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid var(--border);
            text-align: center;
            font-size: 12px;
            color: var(--text-dim);
        }

        .modal-footer .authorship {
            margin-bottom: 12px;
        }

        .modal-footer .links {
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .modal-footer a {
            color: var(--amber-dim);
            text-decoration: none;
            transition: color 0.2s;
        }

        .modal-footer a:hover {
            color: var(--amber);
        }
        
        .btn {
            flex: 1;
            padding: 12px 20px;
            font-family: 'VT323', monospace;
            font-size: 18px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s;
        }
        
        .btn-primary {
            background: var(--amber);
            border: none;
            color: var(--bg-dark);
        }
        
        .btn-primary:hover {
            background: var(--amber-bright);
            box-shadow: 0 0 20px var(--amber-glow);
        }
        
        .btn-secondary {
            background: transparent;
            border: 1px solid var(--amber-dim);
            color: var(--amber-dim);
        }
        
        .btn-secondary:hover {
            border-color: var(--amber);
            color: var(--amber);
        }
        
        /* ===== MAIN APP ===== */
        #app {
            display: none;
            height: 100vh;
        }
        
        #app.active {
            display: flex;
        }
        
        /* Header */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 50px;
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 50;
        }
        
        .header-left {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .header-title {
            font-family: 'VT323', monospace;
            font-size: 20px;
            letter-spacing: 2px;
        }
        
        .header-right {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .model-indicator {
            font-size: 11px;
            color: var(--amber-dim);
            background: rgba(255, 176, 0, 0.1);
            padding: 4px 10px;
            border-radius: 3px;
            border: 1px solid var(--border);
            font-family: 'IBM Plex Mono', monospace;
        }

        .settings-btn {
            background: none;
            border: none;
            color: var(--amber-dim);
            font-size: 20px;
            cursor: pointer;
            padding: 5px;
            transition: color 0.2s;
        }
        
        .settings-btn:hover {
            color: var(--amber);
        }
        
        /* Header buttons */
        .header-btn {
            background: none;
            border: 1px solid var(--border);
            color: var(--amber-dim);
            padding: 4px 10px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .header-btn:hover:not(:disabled) {
            border-color: var(--amber);
            color: var(--amber);
        }

        .header-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        /* Main Content */
        .main-content {
            flex: 1;
            margin-top: 50px;
            display: flex;
            flex-direction: column;
            height: calc(100vh - 50px);
        }
        
        /* Story Display */
        .story-container {
            flex: 1;
            overflow-y: auto;
            padding: 30px;
            padding-bottom: 10px;
        }
        
        .story-content {
            max-width: 700px;
            margin: 0 auto;
            line-height: 1.8;
        }
        
        .story-segment {
            margin-bottom: 25px;
            padding-bottom: 25px;
            border-bottom: 1px solid var(--border);
        }
        
        .story-segment:last-child {
            border-bottom: none;
        }
        
        .story-segment.user-input {
            color: var(--amber-bright);
            font-style: italic;
        }
        
        .story-segment.user-input::before {
            content: '> ';
            color: var(--amber-dim);
        }
        
        .story-segment.narration {
            color: var(--amber);
        }

        .story-segment.narration p {
            margin: 0 0 1em 0;
        }

        .story-segment.narration p:last-child {
            margin-bottom: 0;
        }

        /* Markdown-style formatting */
        .story-segment.narration strong {
            color: var(--amber-bright);
            font-weight: 600;
        }

        .story-segment.narration em {
            font-style: italic;
            color: var(--amber);
        }

        /* Dialogue styling */
        .story-segment.narration .dialogue {
            color: var(--amber-bright);
            font-style: italic;
        }

        /* Blockquote for internal thoughts or emphasis */
        .story-segment.narration blockquote {
            border-left: 2px solid var(--amber-dim);
            padding-left: 1em;
            margin: 0.5em 0;
            color: var(--amber-dim);
            font-style: italic;
        }

        /* Narrative hover actions */
        .story-segment.narration {
            position: relative;
        }

        .narrative-actions {
            position: absolute;
            top: 0;
            right: 0;
            display: flex;
            gap: 8px;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .story-segment.narration:hover .narrative-actions {
            opacity: 1;
        }

        .narrative-btn {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            color: var(--text-dim);
            padding: 4px 10px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .narrative-btn:hover {
            border-color: var(--amber);
            color: var(--amber);
            background: rgba(255, 176, 0, 0.1);
        }

        /* Narrative edit mode */
        .story-segment.narration.editing {
            padding: 0;
        }

        .story-segment.narration.editing .narrative-actions {
            display: none;
        }

        .narrative-edit-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .narrative-edit-textarea {
            width: 100%;
            min-height: 200px;
            padding: 15px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 14px;
            line-height: 1.7;
            background: var(--bg-dark);
            border: 1px solid var(--amber-dim);
            color: var(--amber);
            resize: vertical;
            outline: none;
        }

        .narrative-edit-textarea:focus {
            border-color: var(--amber);
            box-shadow: 0 0 10px var(--amber-glow);
        }

        .narrative-edit-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .narrative-edit-btn {
            padding: 8px 20px;
            font-family: 'VT323', monospace;
            font-size: 16px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s;
        }

        .narrative-edit-btn.save {
            background: var(--amber);
            border: none;
            color: var(--bg-dark);
        }

        .narrative-edit-btn.save:hover {
            background: var(--amber-bright);
            box-shadow: 0 0 15px var(--amber-glow);
        }

        .narrative-edit-btn.cancel {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--amber-dim);
        }

        .narrative-edit-btn.cancel:hover {
            border-color: var(--amber);
            color: var(--amber);
        }

        /* Refresh Modal */
        #refresh-modal {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.85);
            z-index: 300;
        }

        #refresh-modal.active {
            display: flex;
        }

        .refresh-modal-content {
            background: var(--bg-panel);
            border: 1px solid var(--amber-dim);
            padding: 30px 40px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 0 40px var(--amber-glow);
        }

        .refresh-modal-content h3 {
            font-family: 'VT323', monospace;
            font-size: 24px;
            margin-bottom: 10px;
            color: var(--amber);
        }

        .refresh-modal-content p {
            color: var(--amber-dim);
            font-size: 13px;
            margin-bottom: 20px;
            line-height: 1.5;
        }

        .refresh-modal-textarea {
            width: 100%;
            min-height: 80px;
            padding: 12px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 14px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            color: var(--amber);
            resize: vertical;
            outline: none;
            margin-bottom: 20px;
        }

        .refresh-modal-textarea:focus {
            border-color: var(--amber);
        }

        .refresh-modal-textarea::placeholder {
            color: var(--text-dim);
        }

        .refresh-modal-buttons {
            display: flex;
            gap: 15px;
            justify-content: flex-end;
        }

        .story-suggestions {
            margin-top: 20px;
            padding: 15px;
            background: rgba(255, 176, 0, 0.05);
            border-left: 2px solid var(--amber-dim);
            position: relative;
        }

        .story-suggestions h4 {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--amber-dim);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .add-option-btn {
            background: none;
            border: 1px dashed var(--border);
            color: var(--text-dim);
            padding: 4px 10px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
            opacity: 0;
        }

        .story-suggestions:hover .add-option-btn {
            opacity: 1;
        }

        .add-option-btn:hover {
            border-color: var(--amber);
            color: var(--amber);
        }
        
        .suggestion-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 0;
            color: var(--amber-dim);
            cursor: pointer;
            transition: color 0.2s;
        }

        .suggestion-item:hover {
            color: var(--amber-bright);
        }

        .suggestion-item .option-text {
            flex: 1;
        }

        .suggestion-item .option-actions {
            display: flex;
            gap: 8px;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .suggestion-item:hover .option-actions {
            opacity: 1;
        }

        .option-btn {
            background: none;
            border: none;
            color: var(--text-dim);
            cursor: pointer;
            padding: 2px 6px;
            font-size: 12px;
            transition: color 0.2s;
        }

        .option-btn:hover {
            color: var(--amber-bright);
        }

        .option-btn.delete:hover {
            color: #ff5050;
        }

        /* Inline edit mode */
        .suggestion-item.editing {
            cursor: default;
        }

        .suggestion-item.editing .option-text {
            display: none;
        }

        .suggestion-item.editing .option-actions {
            display: none;
        }

        .option-edit-input {
            flex: 1;
            padding: 6px 10px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 14px;
            background: var(--bg-dark);
            border: 1px solid var(--amber-dim);
            color: var(--amber);
            outline: none;
        }

        .option-edit-input:focus {
            border-color: var(--amber);
        }
        
        .welcome-message {
            text-align: center;
            padding: 60px 20px;
            color: var(--amber-dim);
        }
        
        .welcome-message h2 {
            font-family: 'VT323', monospace;
            font-size: 28px;
            margin-bottom: 20px;
            color: var(--amber);
        }
        
        .welcome-message p {
            max-width: 500px;
            margin: 0 auto;
            line-height: 1.6;
        }
        
        /* Loading indicator */
        .loading {
            display: inline-block;
            color: var(--amber-dim);
        }
        
        .loading::after {
            content: '▋';
            animation: cursor-blink 0.8s infinite;
        }
        
        @keyframes cursor-blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--bg-dark);
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--amber-dim);
        }
        
        /* Branch notification */
        .branch-notification {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--amber);
            color: var(--bg-dark);
            padding: 12px 25px;
            font-family: 'VT323', monospace;
            font-size: 16px;
            border-radius: 3px;
            box-shadow: 0 0 30px var(--amber-glow);
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 60;
        }
        
        .branch-notification.show {
            opacity: 1;
        }
        
        /* Error display */
        .error-message {
            background: rgba(255, 80, 80, 0.1);
            border: 1px solid #ff5050;
            color: #ff8080;
            padding: 15px;
            margin: 20px 0;
            font-size: 13px;
        }

        /* Delete Modal */
        #delete-modal {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.85);
            z-index: 300;
        }

        #delete-modal.active {
            display: flex;
        }

        .delete-modal-content {
            background: var(--bg-panel);
            border: 1px solid #ff5050;
            padding: 30px 40px;
            max-width: 400px;
            width: 90%;
            text-align: center;
            box-shadow: 0 0 40px rgba(255, 80, 80, 0.2);
        }

        .delete-modal-icon {
            font-size: 48px;
            margin-bottom: 15px;
            color: #ff5050;
        }

        .delete-modal-content h3 {
            font-family: 'VT323', monospace;
            font-size: 24px;
            margin-bottom: 10px;
            color: var(--amber);
        }

        .delete-modal-content p {
            color: var(--amber-dim);
            font-size: 14px;
            margin-bottom: 25px;
            line-height: 1.5;
        }

        .delete-modal-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .btn-danger {
            background: #ff5050;
            border: none;
            color: #fff;
        }

        .btn-danger:hover {
            background: #ff6b6b;
            box-shadow: 0 0 20px rgba(255, 80, 80, 0.3);
        }
    </style>
</head>
<body>
    <!-- Splash Screen -->
    <div id="splash">
        <pre class="ascii-art">
+--------------------------------------------------------------+
|                                                              |
|         CCCC  RRRR    AA   FFFFF TTTTT                       |
|        C      R   R  A  A  F       T                         |
|        C      RRRR   AAAA  FFF     T                         |
|        C      R  R   A  A  F       T                         |
|         CCCC  R   R  A  A  F       T                         |
|                                                              |
|              Y   Y  OOO  U   U RRRR                          |
|               Y Y  O   O U   U R   R                         |
|                Y   O   O U   U RRRR                          |
|                Y   O   O U   U R  R                          |
|                Y    OOO   UUU  R   R                         |
|                                                              |
|                OOO  W   W N   N                              |
|               O   O W   W NN  N                              |
|               O   O W W W N N N                              |
|               O   O WW WW N  NN                              |
|                OOO  W   W N   N                              |
|                                                              |
|     AA  DDD  V   V EEEE N   N TTTTT U   U RRRR  EEEE         |
|    A  A D  D V   V E    NN  N   T   U   U R   R E            |
|    AAAA D  D V   V EEE  N N N   T   U   U RRRR  EEE          |
|    A  A D  D  V V  E    N  NN   T   U   U R  R  E            |
|    A  A DDD    V   EEEE N   N   T    UUU  R   R EEEE         |
|                                                              |
|                       +----------+                           |
|                :::::::| ######## |:::::::                    |
|                :::::::| #      # |:::::::                    |
|                :::::::| #      # |:::::::                    |
|                       +----++----+                           |
|                            ||                                |
|                      WEST OF HOUSE                           |
|                                                              |
|   You are standing in an open field west of a white house,   |
|   with a boarded front door.                                 |
|                                                              |
|   >_                                                         |
|                                                              |
+--------------------------------------------------------------+
        </pre>
        <div class="splash-prompt">Press any key or click to begin...</div>
        <button class="splash-btn" id="start-btn">Enter</button>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal">
        <div class="modal-content">
            <h2>⚙ Configuration</h2>
            <div class="form-group">
                <label>OpenRouter API Key</label>
                <input type="password" id="openrouter-key" placeholder="Enter your OpenRouter API key">
            </div>
            <div class="form-group">
                <label>Craft API URL</label>
                <input type="text" id="craft-token" placeholder="https://connect.craft.do/links/YOUR_LINK/api/v1">
            </div>
            <div class="form-group">
                <label>Document ID (optional - uses first doc if empty)</label>
                <input type="text" id="craft-doc-id" placeholder="Leave empty to auto-select">
            </div>
            <div class="form-group">
                <label>AI Model</label>
                <select id="ai-model">
                    <option value="nex-agi/deepseek-v3.1-nex-n1:free">DeepSeek V3.1 (Free)</option>
                    <option value="mistralai/mistral-7b-instruct:free">Mistral 7B (Free)</option>
                    <option value="google/gemma-2-9b-it:free">Google Gemma 2 9B (Free)</option>
                    <option value="meta-llama/llama-3.2-3b-instruct:free">Llama 3.2 3B (Free)</option>
                </select>
            </div>
            <div class="form-group toggle-group">
                <span class="toggle-label">Dark</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="light-mode-toggle">
                    <span class="toggle-slider"></span>
                </label>
                <span class="toggle-label">Light</span>
            </div>
            <div class="modal-buttons">
                <button class="btn btn-secondary" id="cancel-settings">Cancel</button>
                <button class="btn btn-primary" id="save-settings">Save & Continue</button>
            </div>
            <div class="modal-footer">
                <div class="authorship">Made by Priyan Nithya & Claude Code</div>
                <div class="links">
                    <a href="https://github.com/eternalpriyan/Craft-Your-Own-Adventure" target="_blank">GitHub</a>
                    <a href="https://buymeacoffee.com/npsoy" target="_blank">Buy me a coffee</a>
                </div>
            </div>
        </div>
    </div>

    <!-- Main App -->
    <div id="app">
        <header class="header">
            <div class="header-left">
                <span class="header-title">CRAFT YOUR OWN ADVENTURE</span>
            </div>
            <div class="header-right">
                <span class="model-indicator" id="model-indicator" title="Current AI Model">AI: DeepSeek</span>
                <button class="header-btn" id="back-btn" disabled title="Go back">← Back</button>
                <button class="header-btn" id="refresh-btn" title="Reload from Craft">↻ Refresh</button>
                <button class="settings-btn" id="open-settings" title="Settings">⚙</button>
            </div>
        </header>

        <main class="main-content">
            <div class="story-container" id="story-container">
                <div class="story-content" id="story-content"></div>
            </div>
        </main>
    </div>

    <!-- Branch Notification -->
    <div class="branch-notification" id="branch-notification">
        New branch created!
    </div>

    <!-- Delete Confirmation Modal -->
    <div id="delete-modal">
        <div class="delete-modal-content">
            <div class="delete-modal-icon">⚠</div>
            <h3>Delete Option?</h3>
            <p id="delete-modal-text">Are you sure you want to delete this option?</p>
            <div class="delete-modal-buttons">
                <button class="btn btn-secondary" id="delete-cancel">Cancel</button>
                <button class="btn btn-danger" id="delete-confirm">Delete</button>
            </div>
        </div>
    </div>

    <!-- Refresh/Regenerate Modal -->
    <div id="refresh-modal">
        <div class="refresh-modal-content">
            <h3>Regenerate Narrative</h3>
            <p>What would you like different? Leave blank to let the AI regenerate freely.</p>
            <textarea class="refresh-modal-textarea" id="refresh-prompt" placeholder="e.g., Make it more mysterious, add more dialogue, describe the setting in more detail..."></textarea>
            <div class="refresh-modal-buttons">
                <button class="btn btn-secondary" id="refresh-cancel">Cancel</button>
                <button class="btn btn-primary" id="refresh-confirm">Regenerate</button>
            </div>
        </div>
    </div>

    <script>
        // ===== STATE =====
        const state = {
            openrouterKey: localStorage.getItem('cyoa_openrouter_key') || '',
            craftToken: localStorage.getItem('cyoa_craft_token') || '',
            craftDocId: localStorage.getItem('cyoa_craft_doc_id') || '',
            aiModel: localStorage.getItem('cyoa_ai_model') || 'nex-agi/deepseek-v3.1-nex-n1:free',
            lightMode: localStorage.getItem('cyoa_light_mode') === 'true',
            currentBranchId: null,
            adventureTree: null,
            conversationContext: [],
            isGenerating: false,
            isLoadingTree: false,
            appInitialized: false
        };

        // Apply theme on load
        function applyTheme() {
            if (state.lightMode) {
                document.body.classList.add('light-mode');
            } else {
                document.body.classList.remove('light-mode');
            }
        }
        applyTheme();

        // Model display names
        const modelNames = {
            'nex-agi/deepseek-v3.1-nex-n1:free': 'DeepSeek',
            'mistralai/mistral-7b-instruct:free': 'Mistral',
            'google/gemma-2-9b-it:free': 'Gemma',
            'meta-llama/llama-3.2-3b-instruct:free': 'Llama'
        };

        // ===== DOM ELEMENTS =====
        const $ = id => document.getElementById(id);
        const splash = $('splash');
        const settingsModal = $('settings-modal');
        const app = $('app');
        const storyContent = $('story-content');
        const storyContainer = $('story-container');
        const branchNotification = $('branch-notification');

        // ===== INITIALIZATION =====
        function init() {
            // Splash screen handlers
            $('start-btn').addEventListener('click', handleStart);
            document.addEventListener('keydown', handleStart, { once: true });
            splash.addEventListener('click', e => {
                if (e.target === splash) handleStart();
            });

            // Settings handlers
            $('save-settings').addEventListener('click', saveSettings);
            $('cancel-settings').addEventListener('click', () => {
                settingsModal.classList.remove('active');
                if (state.openrouterKey && state.craftToken && state.craftDocId) {
                    showApp();
                }
            });
            $('open-settings').addEventListener('click', () => {
                populateSettingsForm();
                settingsModal.classList.add('active');
            });

            // Back button
            $('back-btn').addEventListener('click', goBack);

            // Refresh button
            $('refresh-btn').addEventListener('click', refreshFromCraft);

            // Delete modal handlers
            $('delete-confirm').addEventListener('click', confirmDelete);
            $('delete-cancel').addEventListener('click', cancelDelete);

            // Refresh modal handlers
            $('refresh-confirm').addEventListener('click', confirmRefresh);
            $('refresh-cancel').addEventListener('click', cancelRefresh);
        }

        let startHandled = false;
        function handleStart() {
            if (startHandled) return;
            startHandled = true;

            splash.style.display = 'none';

            if (state.openrouterKey && state.craftToken && state.craftDocId) {
                showApp();
            } else {
                populateSettingsForm();
                settingsModal.classList.add('active');
            }
        }

        function populateSettingsForm() {
            $('openrouter-key').value = state.openrouterKey;
            $('craft-token').value = state.craftToken;
            $('craft-doc-id').value = state.craftDocId;
            $('ai-model').value = state.aiModel;
            // Toggle: left = dark, right = light. Checked (right) = light mode
            $('light-mode-toggle').checked = state.lightMode;
        }

        function updateModelIndicator() {
            const indicator = $('model-indicator');
            const displayName = modelNames[state.aiModel] || 'AI';
            indicator.textContent = `AI: ${displayName}`;
            indicator.title = state.aiModel;
        }

        function saveSettings() {
            const openrouterKey = $('openrouter-key').value.trim();
            const craftToken = $('craft-token').value.trim();
            const craftDocId = $('craft-doc-id').value.trim();
            const aiModel = $('ai-model').value;
            // Toggle: left = dark, right = light. Checked (right) = light mode
            const lightMode = $('light-mode-toggle').checked;

            if (!openrouterKey || !craftToken) {
                alert('Please enter your OpenRouter API key and Craft API URL');
                return;
            }

            // Ensure the Craft URL doesn't have trailing slash
            state.openrouterKey = openrouterKey;
            state.craftToken = craftToken.replace(/\/$/, '');
            state.craftDocId = craftDocId; // Can be empty
            state.aiModel = aiModel;
            state.lightMode = lightMode;

            localStorage.setItem('cyoa_openrouter_key', openrouterKey);
            localStorage.setItem('cyoa_craft_token', state.craftToken);
            localStorage.setItem('cyoa_craft_doc_id', craftDocId);
            localStorage.setItem('cyoa_ai_model', aiModel);
            localStorage.setItem('cyoa_light_mode', lightMode);

            applyTheme();
            updateModelIndicator();
            settingsModal.classList.remove('active');
            showApp();
        }

        async function showApp() {
            // Prevent double initialization
            if (state.appInitialized) {
                console.log('App already initialized, skipping showApp()');
                return;
            }
            state.appInitialized = true;

            app.classList.add('active');
            updateModelIndicator();
            await loadAdventureTree();
        }

        // ===== CRAFT API =====
        // Base URL is the full connection URL provided by user (includes /api/v1)
        function getCraftBaseUrl() {
            return state.craftToken; // craftToken is actually the full API URL
        }

        async function craftRequest(endpoint, method = 'GET', body = null) {
            const headers = {
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            };

            const options = { method, headers };
            if (body) options.body = JSON.stringify(body);

            const baseUrl = getCraftBaseUrl();
            const url = `${baseUrl}/${endpoint}`;
            
            const response = await fetch(url, options);
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Craft API error ${response.status}: ${errorText}`);
            }
            return response.json();
        }

        async function loadAdventureTree() {
            // Prevent concurrent loads
            if (state.isLoadingTree) {
                console.log('Already loading tree, skipping...');
                return;
            }
            state.isLoadingTree = true;
            storyContent.innerHTML = '<div class="story-segment narration loading">Generating story...</div>';

            try {
                // First, list all documents to find ours or let user pick
                const docsResponse = await craftRequest('documents');
                const docs = docsResponse.items || [];
                
                if (docs.length === 0) {
                    showError('No documents found in this Craft connection.');
                    return;
                }

                // Find the specified doc or use first one
                let targetDoc = docs.find(d => d.id === state.craftDocId);
                if (!targetDoc) {
                    // If no specific doc ID, use the first non-deleted doc
                    targetDoc = docs.find(d => !d.isDeleted) || docs[0];
                    state.craftDocId = targetDoc.id;
                    localStorage.setItem('cyoa_craft_doc_id', targetDoc.id);
                }

                // Fetch the full document content with all nested blocks
                const docContent = await craftRequest(`blocks?id=${targetDoc.id}&maxDepth=-1`);

                // Debug: log raw API response
                console.log('Raw Craft response:', JSON.stringify(docContent, null, 2));

                // Build tree from blocks - page blocks become branches
                state.adventureTree = buildTreeFromBlocks(docContent, targetDoc.title);
                state.currentBranchId = targetDoc.id;

                // Debug: log tree structure
                console.log('Adventure tree:', JSON.stringify(state.adventureTree, null, 2));

                // Restore last viewed page, or default to root
                const savedPageId = localStorage.getItem('cyoa_current_page');
                const targetPageId = savedPageId && findNode(state.adventureTree, savedPageId)
                    ? savedPageId
                    : targetDoc.id;

                console.log('Navigating to:', targetPageId, savedPageId ? '(restored)' : '(root)');
                await loadPage(targetPageId);
            } catch (error) {
                console.error('Failed to load adventure tree:', error);
                showError(`Failed to load from Craft: ${error.message}`);
            } finally {
                state.isLoadingTree = false;
            }
        }

        function buildTreeFromBlocks(block, fallbackTitle = 'Adventure') {
            // Craft API: page blocks have type='page' and markdown IS the title
            // Text blocks have type='text' and markdown is the content
            const isPage = block.type === 'page';

            const node = {
                id: block.id,
                // For pages, markdown is the title
                title: isPage ? (block.markdown || fallbackTitle) : fallbackTitle,
                content: '', // Content from child text blocks
                children: []  // Child pages (options)
            };

            // Collect content from child TEXT blocks only
            let contentParts = [];

            if (block.content && Array.isArray(block.content)) {
                for (const child of block.content) {
                    if (child.type === 'page') {
                        // Child page (option)
                        const childNode = buildTreeFromBlocks(child, 'Option');
                        node.children.push(childNode);
                    } else if (child.type === 'text' && child.markdown && child.markdown.trim()) {
                        // Text block - add to content
                        contentParts.push(child.markdown.trim());
                    }
                }
            }

            node.content = contentParts.join('\n\n');
            return node;
        }

        // Find parent of a node
        function findParent(tree, targetId, parent = null) {
            if (!tree) return null;
            if (tree.id === targetId) return parent;
            for (const child of tree.children || []) {
                const found = findParent(child, targetId, tree);
                if (found) return found;
            }
            return null;
        }

        // Go back to parent page
        async function goBack() {
            if (state.isGenerating) return;
            const parent = findParent(state.adventureTree, state.currentBranchId);
            if (parent) {
                await loadPage(parent.id);
            }
        }

        // Refresh current page from Craft
        async function refreshFromCraft() {
            if (state.isGenerating || state.isLoadingTree) return;

            const refreshBtn = $('refresh-btn');
            refreshBtn.disabled = true;
            refreshBtn.textContent = '↻ Loading...';

            // Show loading in content area
            storyContent.innerHTML = '<div class="loading">Refreshing from Craft...</div>';

            // Reset initialization flags to allow reload
            state.appInitialized = false;
            state.isLoadingTree = false;

            await loadAdventureTree();

            refreshBtn.disabled = false;
            refreshBtn.textContent = '↻ Refresh';
        }

        // Update back button state
        function updateBackButton() {
            const backBtn = $('back-btn');
            const parent = findParent(state.adventureTree, state.currentBranchId);
            backBtn.disabled = !parent;
        }

        // ===== STEP 0: LOAD PAGE (Central function - everything funnels here) =====
        async function loadPage(pageId) {
            state.currentBranchId = pageId;
            // Remember current location for page refresh
            localStorage.setItem('cyoa_current_page', pageId);
            state.isGenerating = true;

            const node = findNode(state.adventureTree, pageId);
            if (!node) {
                console.error('Node not found:', pageId);
                state.isGenerating = false;
                return;
            }

            // Check if page has content
            const hasContent = node.content && node.content.trim().length > 0;

            if (!hasContent) {
                // EMPTY PAGE: Generate content
                const isRoot = node.id === state.adventureTree?.id;
                console.log('Page empty, generating content for:', node.title, isRoot ? '(root)' : '');

                storyContent.innerHTML = '<div class="story-segment narration loading">Generating story...</div>';
                scrollToBottom();

                try {
                    let narrative, options;

                    if (isRoot) {
                        // EMPTY ROOT: Use predetermined welcome message and starter options
                        narrative = `Welcome, Adventurer. Your story awaits. Pick a path below to begin, or rewrite these options to craft something uniquely yours. Every choice branches into new possibilities, all preserved in your Craft document as a living record of your tale.`;
                        options = [
                            "Into the Dragon's Lair",
                            "The Lost Temple Adventure",
                            "The Space Odyssey"
                        ];
                    } else {
                        // Normal empty page: generate via AI
                        narrative = await generateNarrative(node.title);
                        options = await generateOptions(narrative);
                    }

                    // Update local tree immediately (optimistic UI)
                    node.content = narrative;

                    // Add children to local tree with temp IDs
                    for (const optionTitle of options) {
                        const tempId = 'temp-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
                        node.children.push({
                            id: tempId,
                            title: optionTitle,
                            content: '',
                            children: []
                        });
                    }

                    // Display immediately - don't wait for Craft
                    displayPage(node);
                    updateBackButton();
                    state.isGenerating = false;

                    // Sync to Craft in background (fire and forget)
                    syncPageToCraft(pageId, narrative, options).catch(err => {
                        console.error('Background Craft sync failed:', err);
                    });

                    return; // Already displayed, exit early

                } catch (error) {
                    console.error('Generation error:', error);
                    storyContent.innerHTML = `<div class="error-message">Error: ${error.message}</div>`;
                    state.isGenerating = false;
                    return;
                }
            }

            // Display content and options
            displayPage(node);
            updateBackButton();

            state.isGenerating = false;
        }

        // Display page content and child pages as options
        function displayPage(node) {
            let html = '';

            // Show page title as header (skip for root document)
            const isRoot = node.id === state.adventureTree?.id;
            if (!isRoot) {
                html += `<div class="story-segment user-input">${escapeHtml(node.title)}</div>`;
            }

            // Show content (narrative) - convert line breaks to HTML and parse markdown
            if (node.content && node.content.trim()) {
                const paragraphs = node.content.split('\n\n').filter(p => p.trim());
                const contentHtml = paragraphs.map(p => `<p>${parseMarkdown(p.trim())}</p>`).join('');
                html += `
                    <div class="story-segment narration" data-page-id="${node.id}">
                        <div class="narrative-actions">
                            <button class="narrative-btn" onclick="editNarrative('${node.id}')" title="Edit">✎ Edit</button>
                            <button class="narrative-btn" onclick="refreshNarrative('${node.id}')" title="Regenerate">↻ Refresh</button>
                        </div>
                        <div class="narrative-content">${contentHtml}</div>
                    </div>`;
            }

            // Show child pages as options
            if (node.children && node.children.length > 0) {
                const optionsHtml = node.children.map(child => {
                    const hasChildContent = child.content && child.content.trim().length > 0;
                    const statusClass = hasChildContent ? 'explored' : 'unexplored';
                    const statusIcon = hasChildContent ? '✓' : '→';
                    return `
                        <div class="suggestion-item ${statusClass}" data-page-id="${child.id}">
                            <span class="option-text" onclick="selectOption('${child.id}')">${statusIcon} ${escapeHtml(child.title)}</span>
                            <div class="option-actions">
                                <button class="option-btn edit" onclick="editOption(event, '${child.id}')" title="Edit">✎</button>
                                <button class="option-btn delete" onclick="deleteOption(event, '${child.id}')" title="Delete">✕</button>
                            </div>
                        </div>`;
                }).join('');

                html += `
                    <div class="story-suggestions">
                        <h4>
                            <span>What will you do?</span>
                            <button class="add-option-btn" onclick="addNewOption()">+ New option</button>
                        </h4>
                        ${optionsHtml}
                    </div>
                `;
            }

            storyContent.innerHTML = html;
            scrollToBottom();
        }

        // Refresh a node's data from Craft
        async function refreshNode(pageId) {
            try {
                const response = await craftRequest(`blocks?id=${pageId}&maxDepth=1`);
                const node = findNode(state.adventureTree, pageId);
                if (node && response) {
                    // Update children from response
                    // For page blocks, markdown IS the title (not wrapped in <page> tags)
                    node.children = (response.content || [])
                        .filter(c => c.type === 'page')
                        .map(c => ({
                            id: c.id,
                            title: c.markdown || 'Option',
                            content: '',  // Content is in child text blocks, not fetched here
                            children: []
                        }));
                }
            } catch (error) {
                console.error('Failed to refresh node:', error);
            }
        }

        // Background sync to Craft (optimistic UI - display first, sync later)
        async function syncPageToCraft(pageId, narrative, options) {
            const node = findNode(state.adventureTree, pageId);
            if (!node) return;

            // 1. Write narrative to Craft
            await writeToCraft(narrative);

            // 2. Create child pages in Craft and update local IDs
            for (let i = 0; i < options.length; i++) {
                const optionTitle = options[i];
                try {
                    const response = await craftRequest('blocks', 'POST', {
                        markdown: `<page>${optionTitle}</page>`,
                        position: {
                            position: 'end',
                            pageId: pageId
                        }
                    });

                    const newPageId = response.items?.[0]?.id;
                    if (newPageId && node.children[i] && node.children[i].id.startsWith('temp-')) {
                        // Update temp ID to real Craft ID
                        node.children[i].id = newPageId;
                    }
                } catch (err) {
                    console.error('Failed to create option in Craft:', optionTitle, err);
                }
            }

            // Re-render if still on this page (so onclick handlers get real IDs)
            if (state.currentBranchId === pageId) {
                displayPage(node);
            }

            console.log('Background Craft sync complete for:', pageId);
        }

        // ===== MOCK AI FUNCTIONS =====
        async function generateNarrative(choice) {
            await new Promise(r => setTimeout(r, 500)); // Simulate delay
            return `You chose: "${choice}"

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.

Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.`;
        }

        async function generateOptions(narrative) {
            await new Promise(r => setTimeout(r, 200)); // Simulate delay
            // Mock: Always return 3 fixed options
            return [
                "Explore the ancient ruins",
                "Follow the mysterious stranger",
                "Return to the village"
            ];
        }

        function findNode(tree, id) {
            if (!tree) return null;
            if (tree.id === id) return tree;
            for (const child of tree.children || []) {
                const found = findNode(child, id);
                if (found) return found;
            }
            return null;
        }

        // ===== GLOBAL FUNCTIONS =====
        // Global function for clicking an option (child page)
        window.selectOption = function(pageId) {
            if (state.isGenerating) return;
            loadPage(pageId);
        };

        // Edit an option inline
        window.editOption = function(event, pageId) {
            event.stopPropagation();
            if (state.isGenerating) return;

            // Capture parent ID at edit start
            const parentId = state.currentBranchId;
            const node = findNode(state.adventureTree, pageId);
            if (!node) return;

            const itemEl = event.target.closest('.suggestion-item');
            if (!itemEl) return;

            // Enter edit mode
            itemEl.classList.add('editing');

            // Create input field
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'option-edit-input';
            input.value = node.title;
            input.dataset.pageId = pageId;
            input.dataset.originalTitle = node.title;

            const refreshDisplay = () => {
                const parentNode = findNode(state.adventureTree, parentId);
                if (parentNode) {
                    displayPage(parentNode);
                }
            };

            // Handle Enter to save, Escape to cancel
            input.addEventListener('keydown', async (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const newTitle = input.value.trim();
                    if (newTitle && newTitle !== node.title) {
                        await updateOptionTitle(pageId, newTitle, parentId);
                    } else {
                        refreshDisplay();
                    }
                } else if (e.key === 'Escape') {
                    refreshDisplay();
                }
            });

            // Also cancel on blur
            input.addEventListener('blur', () => {
                setTimeout(() => {
                    if (!document.contains(input)) return;
                    refreshDisplay();
                }, 100);
            });

            itemEl.appendChild(input);
            input.focus();
            input.select();
        };

        // Delete an option - show custom modal
        window.deleteOption = function(event, pageId) {
            event.stopPropagation();
            if (state.isGenerating) return;

            const node = findNode(state.adventureTree, pageId);
            if (!node) return;

            // Show custom delete modal
            const modal = $('delete-modal');
            const modalText = $('delete-modal-text');
            modalText.textContent = `"${truncate(node.title, 40)}"`;
            modal.classList.add('active');

            // Store pageId and parentId for confirm handler
            modal.dataset.pageId = pageId;
            modal.dataset.parentId = state.currentBranchId;
        };

        // Confirm delete from modal
        async function confirmDelete() {
            const modal = $('delete-modal');
            const pageId = modal.dataset.pageId;
            const parentId = modal.dataset.parentId;
            modal.classList.remove('active');

            if (!pageId || !parentId) return;

            // Optimistic UI - remove immediately
            const parentNode = findNode(state.adventureTree, parentId);
            if (parentNode) {
                parentNode.children = parentNode.children.filter(c => c.id !== pageId);
                displayPage(parentNode);
            }

            // Sync with Craft in background
            deleteBlock(pageId).catch(error => {
                console.error('Failed to sync delete with Craft:', error);
            });
        }

        function cancelDelete() {
            $('delete-modal').classList.remove('active');
        }

        // ===== NARRATIVE EDIT/REFRESH =====
        // Edit narrative inline
        window.editNarrative = function(pageId) {
            if (state.isGenerating) return;

            const node = findNode(state.adventureTree, pageId);
            if (!node) return;

            const narrativeEl = document.querySelector(`.story-segment.narration[data-page-id="${pageId}"]`);
            if (!narrativeEl) return;

            // Enter edit mode
            narrativeEl.classList.add('editing');

            // Replace content with textarea
            narrativeEl.innerHTML = `
                <div class="narrative-edit-container">
                    <textarea class="narrative-edit-textarea" id="narrative-edit-textarea">${escapeHtml(node.content)}</textarea>
                    <div class="narrative-edit-buttons">
                        <button class="narrative-edit-btn cancel" onclick="cancelEditNarrative('${pageId}')">Cancel</button>
                        <button class="narrative-edit-btn save" onclick="saveNarrative('${pageId}')">Save</button>
                    </div>
                </div>
            `;

            // Focus the textarea
            const textarea = document.getElementById('narrative-edit-textarea');
            textarea.focus();
            textarea.setSelectionRange(textarea.value.length, textarea.value.length);

            // Handle Escape to cancel
            textarea.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    cancelEditNarrative(pageId);
                } else if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
                    e.preventDefault();
                    saveNarrative(pageId);
                }
            });
        };

        // Save edited narrative
        window.saveNarrative = async function(pageId) {
            const textarea = document.getElementById('narrative-edit-textarea');
            if (!textarea) return;

            const newContent = textarea.value.trim();
            if (!newContent) {
                cancelEditNarrative(pageId);
                return;
            }

            const node = findNode(state.adventureTree, pageId);
            if (!node) return;

            // Update local tree immediately
            node.content = newContent;

            // Re-render the CURRENT page (not necessarily the edited node)
            const currentNode = findNode(state.adventureTree, state.currentBranchId);
            if (currentNode) {
                displayPage(currentNode);
            }

            // Update Craft in background
            console.log('Saving narrative to Craft for page:', pageId);
            updateNarrativeInCraft(pageId, newContent).then(() => {
                console.log('Successfully synced narrative to Craft');
            }).catch(error => {
                console.error('Failed to sync narrative with Craft:', error);
            });
        };

        // Cancel narrative edit
        window.cancelEditNarrative = function(pageId) {
            // Re-render the CURRENT page
            const currentNode = findNode(state.adventureTree, state.currentBranchId);
            if (currentNode) {
                displayPage(currentNode);
            }
        };

        // Open refresh modal
        window.refreshNarrative = function(pageId) {
            if (state.isGenerating) return;

            const modal = $('refresh-modal');
            const promptInput = $('refresh-prompt');

            // Clear previous prompt
            promptInput.value = '';

            // Store pageId for confirm handler
            modal.dataset.pageId = pageId;
            modal.classList.add('active');

            // Focus the input
            promptInput.focus();

            // Handle Enter to confirm
            promptInput.addEventListener('keydown', function handler(e) {
                if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
                    e.preventDefault();
                    confirmRefresh();
                    promptInput.removeEventListener('keydown', handler);
                } else if (e.key === 'Escape') {
                    cancelRefresh();
                    promptInput.removeEventListener('keydown', handler);
                }
            });
        };

        // Confirm refresh from modal
        async function confirmRefresh() {
            const modal = $('refresh-modal');
            const pageId = modal.dataset.pageId;
            const prompt = $('refresh-prompt').value.trim();
            modal.classList.remove('active');

            if (!pageId) return;

            const node = findNode(state.adventureTree, pageId);
            if (!node) return;

            state.isGenerating = true;

            // Show loading state
            const narrativeEl = document.querySelector(`.story-segment.narration[data-page-id="${pageId}"]`);
            if (narrativeEl) {
                narrativeEl.innerHTML = '<div class="loading">Regenerating...</div>';
            }

            try {
                // Generate new narrative with optional prompt
                const newContent = await regenerateNarrative(node.title, node.content, prompt);

                // Update local tree
                node.content = newContent;

                // Re-render the CURRENT page
                const currentNode = findNode(state.adventureTree, state.currentBranchId);
                if (currentNode) {
                    displayPage(currentNode);
                }

                // Update Craft in background
                console.log('Saving regenerated narrative to Craft for page:', pageId);
                updateNarrativeInCraft(pageId, newContent).then(() => {
                    console.log('Successfully synced regenerated narrative to Craft');
                }).catch(error => {
                    console.error('Failed to sync regenerated narrative with Craft:', error);
                });

            } catch (error) {
                console.error('Regeneration error:', error);
                // Restore original content on error
                const currentNode = findNode(state.adventureTree, state.currentBranchId);
                if (currentNode) {
                    displayPage(currentNode);
                }
            }

            state.isGenerating = false;
        }

        function cancelRefresh() {
            $('refresh-modal').classList.remove('active');
        }

        // Regenerate narrative with optional guidance
        async function regenerateNarrative(choice, currentContent, guidance) {
            // Mock implementation - replace with real OpenRouter call
            await new Promise(r => setTimeout(r, 800));

            if (guidance) {
                return `[Regenerated with guidance: "${guidance}"]\n\nYou chose: "${choice}"\n\nThe story continues with your requested changes. Lorem ipsum dolor sit amet, consectetur adipiscing elit. This narrative has been adjusted based on your feedback.\n\nDuis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.`;
            } else {
                return `[Regenerated freely]\n\nYou chose: "${choice}"\n\nA fresh take on the narrative unfolds. Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium.\n\nNemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit.`;
            }
        }

        // Update narrative content in Craft
        // Craft stores each paragraph as a separate text block, so we need to handle that
        // NOTE: We only touch TEXT blocks, never page blocks (they have nested content!)
        async function updateNarrativeInCraft(pageId, newContent) {
            console.log('updateNarrativeInCraft called with pageId:', pageId);

            // Fetch current page structure
            const response = await craftRequest(`blocks?id=${pageId}&maxDepth=1`);
            console.log('Fetched page structure:', response);

            // Only touch text blocks - NEVER delete page blocks (they have nested content!)
            const textBlocks = (response.content || []).filter(c => c.type === 'text');
            console.log('Found text blocks:', textBlocks.length);

            // Split new content into paragraphs (Craft stores each as separate block)
            const paragraphs = newContent.split('\n\n').filter(p => p.trim());
            console.log('New content has', paragraphs.length, 'paragraphs');

            // Step 1: Delete existing text blocks only
            if (textBlocks.length > 0) {
                console.log('Deleting', textBlocks.length, 'text blocks...');
                const blockIds = textBlocks.map(b => b.id);
                await craftRequest('blocks', 'DELETE', { blockIds });
            }

            // Step 2: Create new text blocks at START of page (before options)
            console.log('Creating', paragraphs.length, 'text blocks at start...');
            for (let i = paragraphs.length - 1; i >= 0; i--) {
                const paragraph = paragraphs[i].trim();
                if (!paragraph) continue;
                await craftRequest('blocks', 'POST', {
                    markdown: paragraph,
                    position: { position: 'start', pageId: pageId }
                });
            }

            console.log('Successfully updated narrative in Craft');
        }

        // Add a new option
        window.addNewOption = async function() {
            if (state.isGenerating) return;

            const parentId = state.currentBranchId;
            const parentNode = findNode(state.adventureTree, parentId);
            if (!parentNode) return;

            // Create temporary placeholder in local tree
            const tempId = 'temp-' + Date.now();
            const newNode = {
                id: tempId,
                title: '',
                content: '',
                children: []
            };
            parentNode.children.push(newNode);

            // Re-render to show the new option
            displayPage(parentNode);

            // Find the new item and trigger edit mode
            const newItem = document.querySelector(`[data-page-id="${tempId}"]`);
            if (newItem) {
                newItem.classList.add('editing');

                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'option-edit-input';
                input.placeholder = 'Enter option text...';
                input.dataset.pageId = tempId;
                input.dataset.isNew = 'true';

                const cancelNewOption = () => {
                    const currentParent = findNode(state.adventureTree, parentId);
                    if (currentParent) {
                        currentParent.children = currentParent.children.filter(c => c.id !== tempId);
                        displayPage(currentParent);
                    }
                };

                input.addEventListener('keydown', async (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        const title = input.value.trim();
                        if (title) {
                            await saveNewOption(tempId, title, parentId);
                        } else {
                            cancelNewOption();
                        }
                    } else if (e.key === 'Escape') {
                        cancelNewOption();
                    }
                });

                input.addEventListener('blur', () => {
                    setTimeout(() => {
                        // Check if input still exists (wasn't already handled by Enter/Escape)
                        if (!document.contains(input)) return;
                        const title = input.value.trim();
                        if (title) {
                            saveNewOption(tempId, title, parentId);
                        } else {
                            cancelNewOption();
                        }
                    }, 100);
                });

                newItem.appendChild(input);
                input.focus();
            }
        };

        // Save a new option to Craft
        async function saveNewOption(tempId, title, parentId) {
            const parentNode = findNode(state.adventureTree, parentId);
            if (!parentNode) return;

            // Update local tree immediately with title
            const tempNode = parentNode.children.find(c => c.id === tempId);
            if (tempNode) {
                tempNode.title = title;
            }

            // Refresh display instantly
            displayPage(parentNode);

            // Create in Craft in background (don't use createEmptyChildPage - it adds to tree)
            try {
                const response = await craftRequest('blocks', 'POST', {
                    markdown: `<page>${title}</page>`,
                    position: {
                        position: 'end',
                        pageId: parentId
                    }
                });

                const newPageId = response.items?.[0]?.id;
                if (newPageId && tempNode) {
                    // Update the temp ID to real ID
                    tempNode.id = newPageId;
                    // Re-render if still on this page (so onclick handlers get real ID)
                    if (state.currentBranchId === parentId) {
                        displayPage(parentNode);
                    }
                }
            } catch (error) {
                console.error('Failed to create option in Craft:', error);
            }
        }

        async function writeToCraft(content) {
            try {
                console.log('Writing content to Craft page:', state.currentBranchId);

                // Insert content using markdown format
                const response = await craftRequest('blocks', 'POST', {
                    markdown: content,
                    position: {
                        position: 'end',
                        pageId: state.currentBranchId
                    }
                });

                console.log('Write to Craft response:', response);

                // Update local tree - use content property now
                const node = findNode(state.adventureTree, state.currentBranchId);
                if (node) {
                    node.content = content;
                }
            } catch (error) {
                console.error('Failed to write to Craft:', error);
                throw error;
            }
        }

        // Update option title in Craft (optimistic UI)
        async function updateOptionTitle(pageId, newTitle, parentId) {
            // Update local tree immediately
            const node = findNode(state.adventureTree, pageId);
            if (node) {
                node.title = newTitle;
            }

            // Refresh display instantly using captured parentId
            const parentNode = findNode(state.adventureTree, parentId);
            if (parentNode) {
                displayPage(parentNode);
            }

            // Sync with Craft in background
            craftRequest('blocks', 'PUT', {
                blocks: [{
                    id: pageId,
                    markdown: newTitle
                }]
            }).catch(error => {
                console.error('Failed to sync with Craft:', error);
            });
        }

        // Delete a block from Craft
        async function deleteBlock(blockId) {
            // Craft API uses DELETE /blocks with JSON body containing blockIds array
            const response = await craftRequest('blocks', 'DELETE', {
                blockIds: [blockId]
            });
            return response;
        }

        function showBranchNotification(title) {
            branchNotification.textContent = `New branch: ${title}`;
            branchNotification.classList.add('show');
            setTimeout(() => {
                branchNotification.classList.remove('show');
            }, 3000);
        }

        // ===== OPENROUTER API =====
        async function callOpenRouter(prompt) {
            const systemPrompt = `You are an interactive fiction narrator. The player drives the story through their choices.

RULES:
- Write vivid, second-person narrative ("You see...", "You feel...")
- Keep responses 2-4 paragraphs
- End EVERY response with 2-3 suggested actions (but player can do anything)
- When player makes a SIGNIFICANT choice that changes direction, prefix your response with [BRANCH: brief title]
- Never break character or mention game mechanics

FORMAT:
[Narrative paragraphs]

---
**What will you do?**
• [Suggestion 1]
• [Suggestion 2]
• [Suggestion 3]`;

            const messages = [
                {
                    role: 'system',
                    content: systemPrompt
                }
            ];

            // Add conversation context
            for (const ctx of state.conversationContext) {
                if (ctx.type === 'user-input') {
                    messages.push({ role: 'user', content: ctx.text });
                } else if (ctx.type === 'narration') {
                    messages.push({ role: 'assistant', content: ctx.text });
                }
            }

            // Add current prompt
            messages.push({ role: 'user', content: prompt });

            const response = await fetch(
                'https://openrouter.ai/api/v1/chat/completions',
                {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${state.openrouterKey}`,
                        'HTTP-Referer': window.location.href,
                        'X-Title': 'Choose Your Own Adventure'
                    },
                    body: JSON.stringify({
                        model: state.aiModel,
                        messages: messages,
                        stream: true,
                        temperature: 0.9,
                        max_tokens: 1024
                    })
                }
            );

            if (!response.ok) {
                if (response.status === 429) {
                    throw new Error("Uh oh! We've hit the rate limit for this free API. Please choose another LLM in Settings.");
                }
                const errorText = await response.text();
                throw new Error(`OpenRouter API error: ${response.status} - ${errorText}`);
            }

            return response;
        }

        async function processOpenRouterStream(response, onChunk) {
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';
            let fullText = '';

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                buffer += decoder.decode(value, { stream: true });

                // Process complete SSE events
                const lines = buffer.split('\n');
                buffer = lines.pop() || ''; // Keep incomplete line in buffer

                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        const jsonStr = line.substring(6).trim();
                        if (jsonStr && jsonStr !== '[DONE]') {
                            try {
                                const data = JSON.parse(jsonStr);
                                const text = data.choices?.[0]?.delta?.content;
                                if (text) {
                                    fullText += text;
                                    onChunk(fullText);
                                }
                            } catch (e) {
                                // Skip malformed JSON chunks
                            }
                        }
                    }
                }
            }

            return fullText;
        }

        // ===== UTILITIES =====
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Simple markdown parser for narrative text
        function parseMarkdown(text) {
            let html = escapeHtml(text);

            // Bold: **text** or __text__
            html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
            html = html.replace(/__(.+?)__/g, '<strong>$1</strong>');

            // Italic: *text* or _text_
            html = html.replace(/\*([^*]+?)\*/g, '<em>$1</em>');
            html = html.replace(/_([^_]+?)_/g, '<em>$1</em>');

            // Dialogue: "text" - wrap in span with dialogue class
            html = html.replace(/"([^"]+)"/g, '<span class="dialogue">"$1"</span>');

            // Blockquote lines starting with >
            html = html.replace(/^&gt;\s*(.+)$/gm, '<blockquote>$1</blockquote>');

            return html;
        }

        function truncate(str, len) {
            return str.length > len ? str.substring(0, len) + '...' : str;
        }

        function scrollToBottom() {
            storyContainer.scrollTop = storyContainer.scrollHeight;
        }

        function showError(message) {
            storyContent.innerHTML = `<div class="error-message">${escapeHtml(message)}</div>`;
        }

        // Initialize on load
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
