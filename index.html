<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Craft Your Own Adventure</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&family=IBM+Plex+Mono:wght@400;500;600&display=swap');
        
        :root {
            --bg-dark: #0a0a0f;
            --bg-panel: #12121a;
            --amber: #ffb000;
            --amber-dim: #cc8c00;
            --amber-glow: #ffb00033;
            --amber-bright: #ffc940;
            --text-dim: #665c40;
            --border: #2a2a35;
            --scanline: rgba(255, 176, 0, 0.03);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'IBM Plex Mono', monospace;
            background: var(--bg-dark);
            color: var(--amber);
            min-height: 100vh;
            overflow: hidden;
        }
        
        /* CRT Scanline Effect */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                var(--scanline) 2px,
                var(--scanline) 4px
            );
            pointer-events: none;
            z-index: 9999;
        }
        
        /* Screen flicker effect */
        @keyframes flicker {
            0%, 100% { opacity: 1; }
            92% { opacity: 1; }
            93% { opacity: 0.8; }
            94% { opacity: 1; }
        }
        
        body {
            animation: flicker 8s infinite;
        }
        
        /* ===== SPLASH SCREEN ===== */
        #splash {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: var(--bg-dark);
            z-index: 100;
            padding: 20px;
        }
        
        .ascii-art {
            font-family: 'VT323', monospace;
            font-size: 14px;
            line-height: 1.2;
            white-space: pre;
            color: var(--amber);
            text-shadow: 0 0 10px var(--amber-glow), 0 0 20px var(--amber-glow);
            margin-bottom: 40px;
        }
        
        @media (max-width: 700px) {
            .ascii-art {
                font-size: 8px;
            }
        }
        
        .splash-prompt {
            font-family: 'IBM Plex Mono', monospace;
            color: var(--amber-dim);
            font-size: 16px;
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        .splash-btn {
            margin-top: 30px;
            padding: 12px 40px;
            font-family: 'VT323', monospace;
            font-size: 24px;
            background: transparent;
            border: 2px solid var(--amber);
            color: var(--amber);
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .splash-btn:hover {
            background: var(--amber);
            color: var(--bg-dark);
            box-shadow: 0 0 20px var(--amber-glow), 0 0 40px var(--amber-glow);
        }
        
        /* ===== SETTINGS MODAL ===== */
        #settings-modal {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.9);
            z-index: 200;
        }
        
        #settings-modal.active {
            display: flex;
        }
        
        .modal-content {
            background: var(--bg-panel);
            border: 1px solid var(--amber-dim);
            padding: 40px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 0 40px var(--amber-glow);
        }
        
        .modal-content h2 {
            font-family: 'VT323', monospace;
            font-size: 28px;
            margin-bottom: 30px;
            text-transform: uppercase;
            letter-spacing: 3px;
        }
        
        .form-group {
            margin-bottom: 25px;
        }
        
        .form-group label {
            display: block;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--amber-dim);
            margin-bottom: 8px;
        }
        
        .form-group input {
            width: 100%;
            padding: 12px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 14px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            color: var(--amber);
            outline: none;
            transition: border-color 0.2s;
        }
        
        .form-group input:focus {
            border-color: var(--amber);
        }
        
        .form-group input::placeholder {
            color: var(--text-dim);
        }

        .form-group select {
            width: 100%;
            padding: 12px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 14px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            color: var(--amber);
            outline: none;
            cursor: pointer;
            transition: border-color 0.2s;
        }

        .form-group select:focus {
            border-color: var(--amber);
        }

        .form-group select option {
            background: var(--bg-dark);
            color: var(--amber);
        }

        .modal-buttons {
            display: flex;
            gap: 15px;
            margin-top: 30px;
        }
        
        .btn {
            flex: 1;
            padding: 12px 20px;
            font-family: 'VT323', monospace;
            font-size: 18px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s;
        }
        
        .btn-primary {
            background: var(--amber);
            border: none;
            color: var(--bg-dark);
        }
        
        .btn-primary:hover {
            background: var(--amber-bright);
            box-shadow: 0 0 20px var(--amber-glow);
        }
        
        .btn-secondary {
            background: transparent;
            border: 1px solid var(--amber-dim);
            color: var(--amber-dim);
        }
        
        .btn-secondary:hover {
            border-color: var(--amber);
            color: var(--amber);
        }
        
        /* ===== MAIN APP ===== */
        #app {
            display: none;
            height: 100vh;
        }
        
        #app.active {
            display: flex;
        }
        
        /* Header */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 50px;
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 50;
        }
        
        .header-left {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .tree-toggle {
            background: none;
            border: 1px solid var(--border);
            color: var(--amber-dim);
            padding: 6px 12px;
            font-family: 'VT323', monospace;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .tree-toggle:hover,
        .tree-toggle.active {
            border-color: var(--amber);
            color: var(--amber);
        }
        
        .header-title {
            font-family: 'VT323', monospace;
            font-size: 20px;
            letter-spacing: 2px;
        }
        
        .header-right {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .model-indicator {
            font-size: 11px;
            color: var(--amber-dim);
            background: rgba(255, 176, 0, 0.1);
            padding: 4px 10px;
            border-radius: 3px;
            border: 1px solid var(--border);
            font-family: 'IBM Plex Mono', monospace;
        }

        .settings-btn {
            background: none;
            border: none;
            color: var(--amber-dim);
            font-size: 20px;
            cursor: pointer;
            padding: 5px;
            transition: color 0.2s;
        }
        
        .settings-btn:hover {
            color: var(--amber);
        }
        
        /* Tree Panel */
        .tree-panel {
            position: fixed;
            top: 50px;
            left: 0;
            bottom: 0;
            width: 280px;
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            z-index: 40;
            overflow-y: auto;
            padding: 20px;
        }
        
        .tree-panel.open {
            transform: translateX(0);
        }
        
        .tree-header {
            font-family: 'VT323', monospace;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--amber-dim);
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border);
        }
        
        .tree-node {
            padding: 8px 0;
            padding-left: 15px;
            border-left: 1px solid var(--border);
            margin-left: 8px;
        }
        
        .tree-node:first-child {
            border-left: none;
            margin-left: 0;
            padding-left: 0;
        }
        
        .tree-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            cursor: pointer;
            border-radius: 3px;
            transition: all 0.2s;
            font-size: 13px;
            color: var(--amber-dim);
        }
        
        .tree-item:hover {
            background: rgba(255, 176, 0, 0.1);
            color: var(--amber);
        }
        
        .tree-item.current {
            background: rgba(255, 176, 0, 0.15);
            color: var(--amber);
            border-left: 2px solid var(--amber);
            margin-left: -2px;
        }
        
        .tree-item-icon {
            font-size: 10px;
        }
        
        .tree-empty {
            color: var(--text-dim);
            font-size: 13px;
            font-style: italic;
            padding: 20px 0;
        }
        
        /* Main Content */
        .main-content {
            flex: 1;
            margin-top: 50px;
            display: flex;
            flex-direction: column;
            height: calc(100vh - 50px);
        }
        
        /* Story Display */
        .story-container {
            flex: 1;
            overflow-y: auto;
            padding: 30px;
            padding-bottom: 10px;
        }
        
        .story-content {
            max-width: 700px;
            margin: 0 auto;
            line-height: 1.8;
        }
        
        .story-segment {
            margin-bottom: 25px;
            padding-bottom: 25px;
            border-bottom: 1px solid var(--border);
        }
        
        .story-segment:last-child {
            border-bottom: none;
        }
        
        .story-segment.user-input {
            color: var(--amber-bright);
            font-style: italic;
        }
        
        .story-segment.user-input::before {
            content: '> ';
            color: var(--amber-dim);
        }
        
        .story-segment.narration {
            color: var(--amber);
        }

        .story-segment.narration p {
            margin: 0 0 1em 0;
        }

        .story-segment.narration p:last-child {
            margin-bottom: 0;
        }

        /* Markdown-style formatting */
        .story-segment.narration strong {
            color: var(--amber-bright);
            font-weight: 600;
        }

        .story-segment.narration em {
            font-style: italic;
            color: var(--amber);
        }

        /* Dialogue styling */
        .story-segment.narration .dialogue {
            color: var(--amber-bright);
            font-style: italic;
        }

        /* Blockquote for internal thoughts or emphasis */
        .story-segment.narration blockquote {
            border-left: 2px solid var(--amber-dim);
            padding-left: 1em;
            margin: 0.5em 0;
            color: var(--amber-dim);
            font-style: italic;
        }
        
        .story-suggestions {
            margin-top: 20px;
            padding: 15px;
            background: rgba(255, 176, 0, 0.05);
            border-left: 2px solid var(--amber-dim);
        }
        
        .story-suggestions h4 {
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--amber-dim);
            margin-bottom: 10px;
        }
        
        .suggestion-item {
            padding: 8px 0;
            color: var(--amber-dim);
            cursor: pointer;
            transition: color 0.2s;
        }
        
        .suggestion-item:hover {
            color: var(--amber-bright);
        }
        
        .suggestion-item::before {
            content: 'â€¢ ';
        }
        
        .welcome-message {
            text-align: center;
            padding: 60px 20px;
            color: var(--amber-dim);
        }
        
        .welcome-message h2 {
            font-family: 'VT323', monospace;
            font-size: 28px;
            margin-bottom: 20px;
            color: var(--amber);
        }
        
        .welcome-message p {
            max-width: 500px;
            margin: 0 auto;
            line-height: 1.6;
        }
        
        /* Input Area */
        .input-container {
            padding: 20px 30px;
            background: var(--bg-panel);
            border-top: 1px solid var(--border);
        }
        
        .input-wrapper {
            max-width: 700px;
            margin: 0 auto;
            display: flex;
            gap: 15px;
        }
        
        .input-field {
            flex: 1;
            padding: 15px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 14px;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            color: var(--amber);
            outline: none;
            resize: none;
            min-height: 50px;
            max-height: 150px;
            transition: border-color 0.2s;
        }
        
        .input-field:focus {
            border-color: var(--amber);
        }
        
        .input-field::placeholder {
            color: var(--text-dim);
        }
        
        .send-btn {
            padding: 15px 25px;
            font-family: 'VT323', monospace;
            font-size: 18px;
            background: var(--amber);
            border: none;
            color: var(--bg-dark);
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s;
            align-self: flex-end;
        }
        
        .send-btn:hover:not(:disabled) {
            background: var(--amber-bright);
            box-shadow: 0 0 20px var(--amber-glow);
        }
        
        .send-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* Loading indicator */
        .loading {
            display: inline-block;
            color: var(--amber-dim);
        }
        
        .loading::after {
            content: 'â–‹';
            animation: cursor-blink 0.8s infinite;
        }
        
        @keyframes cursor-blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--bg-dark);
        }
        
        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--amber-dim);
        }
        
        /* Branch notification */
        .branch-notification {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--amber);
            color: var(--bg-dark);
            padding: 12px 25px;
            font-family: 'VT323', monospace;
            font-size: 16px;
            border-radius: 3px;
            box-shadow: 0 0 30px var(--amber-glow);
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 60;
        }
        
        .branch-notification.show {
            opacity: 1;
        }
        
        /* Error display */
        .error-message {
            background: rgba(255, 80, 80, 0.1);
            border: 1px solid #ff5050;
            color: #ff8080;
            padding: 15px;
            margin: 20px 0;
            font-size: 13px;
        }
    </style>
</head>
<body>
    <!-- Splash Screen -->
    <div id="splash">
        <pre class="ascii-art">
+--------------------------------------------------------------+
|                                                              |
|         CCCC  RRRR    AA   FFFFF TTTTT                       |
|        C      R   R  A  A  F       T                         |
|        C      RRRR   AAAA  FFF     T                         |
|        C      R  R   A  A  F       T                         |
|         CCCC  R   R  A  A  F       T                         |
|                                                              |
|              Y   Y  OOO  U   U RRRR                          |
|               Y Y  O   O U   U R   R                         |
|                Y   O   O U   U RRRR                          |
|                Y   O   O U   U R  R                          |
|                Y    OOO   UUU  R   R                         |
|                                                              |
|                OOO  W   W N   N                              |
|               O   O W   W NN  N                              |
|               O   O W W W N N N                              |
|               O   O WW WW N  NN                              |
|                OOO  W   W N   N                              |
|                                                              |
|     AA  DDD  V   V EEEE N   N TTTTT U   U RRRR  EEEE         |
|    A  A D  D V   V E    NN  N   T   U   U R   R E            |
|    AAAA D  D V   V EEE  N N N   T   U   U RRRR  EEE          |
|    A  A D  D  V V  E    N  NN   T   U   U R  R  E            |
|    A  A DDD    V   EEEE N   N   T    UUU  R   R EEEE         |
|                                                              |
|                       +----------+                           |
|                :::::::| ######## |:::::::                    |
|                :::::::| #      # |:::::::                    |
|                :::::::| #      # |:::::::                    |
|                       +----++----+                           |
|                            ||                                |
|                      WEST OF HOUSE                           |
|                                                              |
|   You are standing in an open field west of a white house,   |
|   with a boarded front door.                                 |
|                                                              |
|   >_                                                         |
|                                                              |
+--------------------------------------------------------------+
        </pre>
        <div class="splash-prompt">Press any key or click to begin...</div>
        <button class="splash-btn" id="start-btn">Enter</button>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal">
        <div class="modal-content">
            <h2>âš™ Configuration</h2>
            <div class="form-group">
                <label>OpenRouter API Key</label>
                <input type="password" id="openrouter-key" placeholder="Enter your OpenRouter API key">
            </div>
            <div class="form-group">
                <label>Craft API URL</label>
                <input type="text" id="craft-token" placeholder="https://connect.craft.do/links/YOUR_LINK/api/v1">
            </div>
            <div class="form-group">
                <label>Document ID (optional - uses first doc if empty)</label>
                <input type="text" id="craft-doc-id" placeholder="Leave empty to auto-select">
            </div>
            <div class="form-group">
                <label>AI Model</label>
                <select id="ai-model">
                    <option value="nex-agi/deepseek-v3.1-nex-n1:free">DeepSeek V3.1 (Free)</option>
                    <option value="mistralai/mistral-7b-instruct:free">Mistral 7B (Free)</option>
                    <option value="google/gemma-2-9b-it:free">Google Gemma 2 9B (Free)</option>
                    <option value="meta-llama/llama-3.2-3b-instruct:free">Llama 3.2 3B (Free)</option>
                </select>
            </div>
            <div class="modal-buttons">
                <button class="btn btn-secondary" id="cancel-settings">Cancel</button>
                <button class="btn btn-primary" id="save-settings">Save & Continue</button>
            </div>
        </div>
    </div>

    <!-- Main App -->
    <div id="app">
        <header class="header">
            <div class="header-left">
                <button class="tree-toggle" id="tree-toggle">â˜° Tree</button>
                <span class="header-title">CRAFT YOUR OWN ADVENTURE</span>
            </div>
            <div class="header-right">
                <span class="model-indicator" id="model-indicator" title="Current AI Model">AI: DeepSeek</span>
                <span id="current-branch-name"></span>
                <button class="settings-btn" id="open-settings" title="Settings">âš™</button>
            </div>
        </header>

        <aside class="tree-panel" id="tree-panel">
            <div class="tree-header">ðŸ“– Adventure Map</div>
            <div id="tree-content">
                <div class="tree-empty">No adventures yet. Start your story below.</div>
            </div>
        </aside>

        <main class="main-content">
            <div class="story-container" id="story-container">
                <div class="story-content" id="story-content">
                    <div class="welcome-message">
                        <h2>Your Adventure Awaits</h2>
                        <p>Begin your story by typing a scene, setting, or situation. 
                        The AI will weave your narrative, and every choice you make 
                        will branch into a new path â€” all saved in your Craft document.</p>
                    </div>
                </div>
            </div>
            <div class="input-container">
                <div class="input-wrapper">
                    <textarea 
                        class="input-field" 
                        id="user-input" 
                        placeholder="What do you do? (or describe how your adventure begins...)"
                        rows="1"
                    ></textarea>
                    <button class="send-btn" id="send-btn">Send</button>
                </div>
            </div>
        </main>
    </div>

    <!-- Branch Notification -->
    <div class="branch-notification" id="branch-notification">
        New branch created!
    </div>

    <script>
        // ===== STATE =====
        const state = {
            openrouterKey: localStorage.getItem('cyoa_openrouter_key') || '',
            craftToken: localStorage.getItem('cyoa_craft_token') || '',
            craftDocId: localStorage.getItem('cyoa_craft_doc_id') || '',
            aiModel: localStorage.getItem('cyoa_ai_model') || 'nex-agi/deepseek-v3.1-nex-n1:free',
            currentBranchId: null,
            adventureTree: null,
            conversationContext: [],
            isGenerating: false
        };

        // Model display names
        const modelNames = {
            'nex-agi/deepseek-v3.1-nex-n1:free': 'DeepSeek',
            'mistralai/mistral-7b-instruct:free': 'Mistral',
            'google/gemma-2-9b-it:free': 'Gemma',
            'meta-llama/llama-3.2-3b-instruct:free': 'Llama'
        };

        // ===== DOM ELEMENTS =====
        const $ = id => document.getElementById(id);
        const splash = $('splash');
        const settingsModal = $('settings-modal');
        const app = $('app');
        const treePanel = $('tree-panel');
        const treeContent = $('tree-content');
        const storyContent = $('story-content');
        const storyContainer = $('story-container');
        const userInput = $('user-input');
        const sendBtn = $('send-btn');
        const branchNotification = $('branch-notification');

        // ===== INITIALIZATION =====
        function init() {
            // Splash screen handlers
            $('start-btn').addEventListener('click', handleStart);
            document.addEventListener('keydown', handleStart, { once: true });
            splash.addEventListener('click', e => {
                if (e.target === splash) handleStart();
            });

            // Settings handlers
            $('save-settings').addEventListener('click', saveSettings);
            $('cancel-settings').addEventListener('click', () => {
                settingsModal.classList.remove('active');
                if (state.openrouterKey && state.craftToken && state.craftDocId) {
                    showApp();
                }
            });
            $('open-settings').addEventListener('click', () => {
                populateSettingsForm();
                settingsModal.classList.add('active');
            });

            // Tree panel toggle
            $('tree-toggle').addEventListener('click', () => {
                treePanel.classList.toggle('open');
                $('tree-toggle').classList.toggle('active');
            });

            // Input handlers
            sendBtn.addEventListener('click', handleSend);
            userInput.addEventListener('keydown', e => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    handleSend();
                }
            });

            // Auto-resize textarea
            userInput.addEventListener('input', () => {
                userInput.style.height = 'auto';
                userInput.style.height = Math.min(userInput.scrollHeight, 150) + 'px';
            });
        }

        function handleStart() {
            splash.style.display = 'none';

            if (state.openrouterKey && state.craftToken && state.craftDocId) {
                showApp();
            } else {
                populateSettingsForm();
                settingsModal.classList.add('active');
            }
        }

        function populateSettingsForm() {
            $('openrouter-key').value = state.openrouterKey;
            $('craft-token').value = state.craftToken;
            $('craft-doc-id').value = state.craftDocId;
            $('ai-model').value = state.aiModel;
        }

        function updateModelIndicator() {
            const indicator = $('model-indicator');
            const displayName = modelNames[state.aiModel] || 'AI';
            indicator.textContent = `AI: ${displayName}`;
            indicator.title = state.aiModel;
        }

        function saveSettings() {
            const openrouterKey = $('openrouter-key').value.trim();
            const craftToken = $('craft-token').value.trim();
            const craftDocId = $('craft-doc-id').value.trim();
            const aiModel = $('ai-model').value;

            if (!openrouterKey || !craftToken) {
                alert('Please enter your OpenRouter API key and Craft API URL');
                return;
            }

            // Ensure the Craft URL doesn't have trailing slash
            state.openrouterKey = openrouterKey;
            state.craftToken = craftToken.replace(/\/$/, '');
            state.craftDocId = craftDocId; // Can be empty
            state.aiModel = aiModel;

            localStorage.setItem('cyoa_openrouter_key', openrouterKey);
            localStorage.setItem('cyoa_craft_token', state.craftToken);
            localStorage.setItem('cyoa_craft_doc_id', craftDocId);
            localStorage.setItem('cyoa_ai_model', aiModel);

            updateModelIndicator();
            settingsModal.classList.remove('active');
            showApp();
        }

        async function showApp() {
            app.classList.add('active');
            updateModelIndicator();
            await loadAdventureTree();
        }

        // ===== CRAFT API =====
        // Base URL is the full connection URL provided by user (includes /api/v1)
        function getCraftBaseUrl() {
            return state.craftToken; // craftToken is actually the full API URL
        }

        async function craftRequest(endpoint, method = 'GET', body = null) {
            const headers = {
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            };

            const options = { method, headers };
            if (body) options.body = JSON.stringify(body);

            const baseUrl = getCraftBaseUrl();
            const url = `${baseUrl}/${endpoint}`;
            
            const response = await fetch(url, options);
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Craft API error ${response.status}: ${errorText}`);
            }
            return response.json();
        }

        async function loadAdventureTree() {
            try {
                // First, list all documents to find ours or let user pick
                const docsResponse = await craftRequest('documents');
                const docs = docsResponse.items || [];
                
                if (docs.length === 0) {
                    showError('No documents found in this Craft connection.');
                    return;
                }

                // Find the specified doc or use first one
                let targetDoc = docs.find(d => d.id === state.craftDocId);
                if (!targetDoc) {
                    // If no specific doc ID, use the first non-deleted doc
                    targetDoc = docs.find(d => !d.isDeleted) || docs[0];
                    state.craftDocId = targetDoc.id;
                    localStorage.setItem('cyoa_craft_doc_id', targetDoc.id);
                }

                // Fetch the full document content with all nested blocks
                const docContent = await craftRequest(`blocks?id=${targetDoc.id}&maxDepth=-1`);

                // Debug: log raw API response
                console.log('Raw Craft response:', JSON.stringify(docContent, null, 2));

                // Build tree from blocks - page blocks become branches
                state.adventureTree = buildTreeFromBlocks(docContent, targetDoc.title);
                state.currentBranchId = targetDoc.id;

                // Debug: log tree structure
                console.log('Adventure tree:', JSON.stringify(state.adventureTree, null, 2));

                // Load the root page (step 0)
                await loadPage(targetDoc.id);
            } catch (error) {
                console.error('Failed to load adventure tree:', error);
                showError(`Failed to load from Craft: ${error.message}`);
            }
        }

        function buildTreeFromBlocks(block, fallbackTitle = 'Adventure') {
            // Craft API: page blocks have type='page' and markdown IS the title
            // Text blocks have type='text' and markdown is the content
            const isPage = block.type === 'page';

            const node = {
                id: block.id,
                // For pages, markdown is the title
                title: isPage ? (block.markdown || fallbackTitle) : fallbackTitle,
                content: '', // Content from child text blocks
                children: []  // Child pages (options)
            };

            // Collect content from child TEXT blocks only
            let contentParts = [];

            if (block.content && Array.isArray(block.content)) {
                for (const child of block.content) {
                    if (child.type === 'page') {
                        // Child page (option)
                        const childNode = buildTreeFromBlocks(child, 'Option');
                        node.children.push(childNode);
                    } else if (child.type === 'text' && child.markdown && child.markdown.trim()) {
                        // Text block - add to content
                        contentParts.push(child.markdown.trim());
                    }
                }
            }

            node.content = contentParts.join('\n\n');
            return node;
        }

        function renderTree() {
            if (!state.adventureTree) {
                treeContent.innerHTML = '<div class="tree-empty">No adventures yet. Start your story below.</div>';
                return;
            }

            treeContent.innerHTML = renderTreeNode(state.adventureTree, 0);
        }

        function renderTreeNode(node, depth) {
            const isCurrent = node.id === state.currentBranchId;
            const icon = node.children.length > 0 ? 'ðŸ“‚' : 'ðŸ“„';
            
            let html = `
                <div class="tree-node">
                    <div class="tree-item ${isCurrent ? 'current' : ''}" data-id="${node.id}">
                        <span class="tree-item-icon">${icon}</span>
                        <span>${truncate(node.title, 25)}</span>
                    </div>
            `;

            if (node.children.length > 0) {
                for (const child of node.children) {
                    html += renderTreeNode(child, depth + 1);
                }
            }

            html += '</div>';
            return html;
        }

        // Add click handlers after rendering
        function attachTreeHandlers() {
            document.querySelectorAll('.tree-item').forEach(item => {
                item.addEventListener('click', () => {
                    const id = item.dataset.id;
                    navigateToBranch(id);
                });
            });
        }

        async function navigateToBranch(id) {
            // All navigation goes through loadPage (step 0)
            await loadPage(id);
        }

        // ===== STEP 0: LOAD PAGE (Central function - everything funnels here) =====
        async function loadPage(pageId) {
            state.currentBranchId = pageId;
            state.isGenerating = true;
            sendBtn.disabled = true;

            const node = findNode(state.adventureTree, pageId);
            if (!node) {
                console.error('Node not found:', pageId);
                state.isGenerating = false;
                sendBtn.disabled = false;
                return;
            }

            // Check if page has content
            const hasContent = node.content && node.content.trim().length > 0;

            if (!hasContent) {
                // EMPTY PAGE: Generate content
                console.log('Page empty, generating content for:', node.title);

                storyContent.innerHTML = '<div class="story-segment narration loading">Generating story...</div>';
                scrollToBottom();

                try {
                    // Generate narrative (mock)
                    const narrative = await generateNarrative(node.title);

                    // Generate options (mock)
                    const options = await generateOptions(narrative);

                    // Write narrative to Craft page
                    await writeToCraft(narrative);

                    // Update local node
                    node.content = narrative;

                    // Create empty child pages for each option
                    for (const optionTitle of options) {
                        await createEmptyChildPage(pageId, optionTitle);
                    }

                    // Refresh tree from Craft to get new children
                    await refreshNode(pageId);

                } catch (error) {
                    console.error('Generation error:', error);
                    storyContent.innerHTML = `<div class="error-message">Error: ${error.message}</div>`;
                    state.isGenerating = false;
                    sendBtn.disabled = false;
                    return;
                }
            }

            // Display content and options
            displayPage(node);

            renderTree();
            attachTreeHandlers();

            state.isGenerating = false;
            sendBtn.disabled = false;
            userInput.focus();
        }

        // Display page content and child pages as options
        function displayPage(node) {
            let html = '';

            // Show page title as header (skip for root document)
            const isRoot = node.id === state.adventureTree?.id;
            if (!isRoot) {
                html += `<div class="story-segment user-input">${escapeHtml(node.title)}</div>`;
            }

            // Show content (narrative) - convert line breaks to HTML and parse markdown
            if (node.content && node.content.trim()) {
                const paragraphs = node.content.split('\n\n').filter(p => p.trim());
                const contentHtml = paragraphs.map(p => `<p>${parseMarkdown(p.trim())}</p>`).join('');
                html += `<div class="story-segment narration">${contentHtml}</div>`;
            }

            // Show child pages as options
            if (node.children && node.children.length > 0) {
                const optionsHtml = node.children.map(child => {
                    const hasChildContent = child.content && child.content.trim().length > 0;
                    const statusClass = hasChildContent ? 'explored' : 'unexplored';
                    const statusIcon = hasChildContent ? 'âœ“' : 'â†’';
                    return `<div class="suggestion-item ${statusClass}" onclick="selectOption('${child.id}')">${statusIcon} ${escapeHtml(child.title)}</div>`;
                }).join('');

                html += `
                    <div class="story-suggestions">
                        <h4>What will you do?</h4>
                        ${optionsHtml}
                    </div>
                `;
            }

            // Show welcome message if root with no content and no children
            if (isRoot && !node.content?.trim() && (!node.children || node.children.length === 0)) {
                html = `
                    <div class="welcome-message">
                        <h2>Your Adventure Awaits</h2>
                        <p>Begin your story by typing a scene, setting, or situation.</p>
                    </div>
                `;
            }

            storyContent.innerHTML = html;
            scrollToBottom();
        }

        // Refresh a node's data from Craft
        async function refreshNode(pageId) {
            try {
                const response = await craftRequest(`blocks?id=${pageId}&maxDepth=1`);
                const node = findNode(state.adventureTree, pageId);
                if (node && response) {
                    // Update children from response
                    // For page blocks, markdown IS the title (not wrapped in <page> tags)
                    node.children = (response.content || [])
                        .filter(c => c.type === 'page')
                        .map(c => ({
                            id: c.id,
                            title: c.markdown || 'Option',
                            content: '',  // Content is in child text blocks, not fetched here
                            children: []
                        }));
                }
            } catch (error) {
                console.error('Failed to refresh node:', error);
            }
        }

        // ===== MOCK AI FUNCTIONS =====
        async function generateNarrative(choice) {
            await new Promise(r => setTimeout(r, 500)); // Simulate delay
            return `You chose: "${choice}"

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.

Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.`;
        }

        async function generateOptions(narrative) {
            await new Promise(r => setTimeout(r, 200)); // Simulate delay
            // Mock: Always return 3 fixed options
            return [
                "Explore the ancient ruins",
                "Follow the mysterious stranger",
                "Return to the village"
            ];
        }

        // Create an empty child page under parent
        async function createEmptyChildPage(parentId, title) {
            try {
                const response = await craftRequest('blocks', 'POST', {
                    markdown: `<page>${title}</page>`,
                    position: {
                        position: 'end',
                        pageId: parentId
                    }
                });

                const newBlockId = response.items?.[0]?.id;
                if (newBlockId) {
                    // Add to local tree
                    const parentNode = findNode(state.adventureTree, parentId);
                    if (parentNode) {
                        parentNode.children.push({
                            id: newBlockId,
                            title: title,
                            content: '',
                            children: []
                        });
                    }
                }
                return newBlockId;
            } catch (error) {
                console.error('Failed to create child page:', error);
                throw error;
            }
        }

        function findNode(tree, id) {
            if (!tree) return null;
            if (tree.id === id) return tree;
            for (const child of tree.children || []) {
                const found = findNode(child, id);
                if (found) return found;
            }
            return null;
        }

        // ===== GLOBAL FUNCTIONS =====
        // Global function for clicking an option (child page)
        window.selectOption = function(pageId) {
            if (state.isGenerating) return;
            loadPage(pageId);
        };

        // Global function for custom input (legacy - now uses handleSend)
        window.useSuggestion = function(text) {
            userInput.value = text;
            handleSend();
        };

        async function writeToCraft(content) {
            try {
                console.log('Writing content to Craft page:', state.currentBranchId);

                // Insert content using markdown format
                const response = await craftRequest('blocks', 'POST', {
                    markdown: content,
                    position: {
                        position: 'end',
                        pageId: state.currentBranchId
                    }
                });

                console.log('Write to Craft response:', response);

                // Update local tree - use content property now
                const node = findNode(state.adventureTree, state.currentBranchId);
                if (node) {
                    node.content = content;
                }
            } catch (error) {
                console.error('Failed to write to Craft:', error);
                throw error;
            }
        }

        function showBranchNotification(title) {
            branchNotification.textContent = `New branch: ${title}`;
            branchNotification.classList.add('show');
            setTimeout(() => {
                branchNotification.classList.remove('show');
            }, 3000);
        }

        // ===== OPENROUTER API =====
        async function callOpenRouter(prompt) {
            const systemPrompt = `You are an interactive fiction narrator. The player drives the story through their choices.

RULES:
- Write vivid, second-person narrative ("You see...", "You feel...")
- Keep responses 2-4 paragraphs
- End EVERY response with 2-3 suggested actions (but player can do anything)
- When player makes a SIGNIFICANT choice that changes direction, prefix your response with [BRANCH: brief title]
- Never break character or mention game mechanics

FORMAT:
[Narrative paragraphs]

---
**What will you do?**
â€¢ [Suggestion 1]
â€¢ [Suggestion 2]
â€¢ [Suggestion 3]`;

            const messages = [
                {
                    role: 'system',
                    content: systemPrompt
                }
            ];

            // Add conversation context
            for (const ctx of state.conversationContext) {
                if (ctx.type === 'user-input') {
                    messages.push({ role: 'user', content: ctx.text });
                } else if (ctx.type === 'narration') {
                    messages.push({ role: 'assistant', content: ctx.text });
                }
            }

            // Add current prompt
            messages.push({ role: 'user', content: prompt });

            const response = await fetch(
                'https://openrouter.ai/api/v1/chat/completions',
                {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${state.openrouterKey}`,
                        'HTTP-Referer': window.location.href,
                        'X-Title': 'Choose Your Own Adventure'
                    },
                    body: JSON.stringify({
                        model: state.aiModel,
                        messages: messages,
                        stream: true,
                        temperature: 0.9,
                        max_tokens: 1024
                    })
                }
            );

            if (!response.ok) {
                if (response.status === 429) {
                    throw new Error("Uh oh! We've hit the rate limit for this free API. Please choose another LLM in Settings.");
                }
                const errorText = await response.text();
                throw new Error(`OpenRouter API error: ${response.status} - ${errorText}`);
            }

            return response;
        }

        async function processOpenRouterStream(response, onChunk) {
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';
            let fullText = '';

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                buffer += decoder.decode(value, { stream: true });

                // Process complete SSE events
                const lines = buffer.split('\n');
                buffer = lines.pop() || ''; // Keep incomplete line in buffer

                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        const jsonStr = line.substring(6).trim();
                        if (jsonStr && jsonStr !== '[DONE]') {
                            try {
                                const data = JSON.parse(jsonStr);
                                const text = data.choices?.[0]?.delta?.content;
                                if (text) {
                                    fullText += text;
                                    onChunk(fullText);
                                }
                            } catch (e) {
                                // Skip malformed JSON chunks
                            }
                        }
                    }
                }
            }

            return fullText;
        }

        // ===== MESSAGE HANDLING =====
        // User types custom message â†’ create empty child page â†’ loadPage (triggers generation)
        async function handleSend() {
            const input = userInput.value.trim();
            if (!input || state.isGenerating) return;

            userInput.value = '';
            userInput.style.height = 'auto';

            try {
                // Create empty child page with user's input as title
                const newPageId = await createEmptyChildPage(state.currentBranchId, input);

                if (newPageId) {
                    // Load the new page (will generate content since empty)
                    await loadPage(newPageId);
                }
            } catch (error) {
                console.error('Failed to create page:', error);
                storyContent.innerHTML += `<div class="error-message">Error: ${error.message}</div>`;
            }
        }

        // ===== UTILITIES =====
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Simple markdown parser for narrative text
        function parseMarkdown(text) {
            let html = escapeHtml(text);

            // Bold: **text** or __text__
            html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
            html = html.replace(/__(.+?)__/g, '<strong>$1</strong>');

            // Italic: *text* or _text_
            html = html.replace(/\*([^*]+?)\*/g, '<em>$1</em>');
            html = html.replace(/_([^_]+?)_/g, '<em>$1</em>');

            // Dialogue: "text" - wrap in span with dialogue class
            html = html.replace(/"([^"]+)"/g, '<span class="dialogue">"$1"</span>');

            // Blockquote lines starting with >
            html = html.replace(/^&gt;\s*(.+)$/gm, '<blockquote>$1</blockquote>');

            return html;
        }

        function truncate(str, len) {
            return str.length > len ? str.substring(0, len) + '...' : str;
        }

        function scrollToBottom() {
            storyContainer.scrollTop = storyContainer.scrollHeight;
        }

        function showError(message) {
            storyContent.innerHTML = `<div class="error-message">${escapeHtml(message)}</div>`;
        }

        // Initialize on load
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
